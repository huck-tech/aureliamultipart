// jQuery is a requirement. But this will help some IDEs
// in terms of suppressing false positive "undefined" errors.

var $ = jQuery || {};
/**
 * Application Namespace with test link to {@link pg.init.trigger}
 *
 * @namespace pg
 */
var pg = pg || {};

//centralNewHost it is a proxy object to rest call made by central to change configuration of TA or get TA status.
centralNewHost = {
  //protocol - > ftp://, http://, https://
  protocol: "",
  //IP -> 256.256.256.256
  ip: document.location.hostname,
  //PORT -> 8080
  port: "",
  //nodeID - > 1485858158858
  nodeID: 0,
  //authorization enconded
  credentials: ""
};

var header = {};
if (centralNewHost.credentials !== "") {
  header.RESTAuthorization = centralNewHost.credentials;
}

$.ajaxSetup({
  cache: false,
  headers: header
});

//before initialize anything get i18n stuff
i18n.init(i18nOptions, function (err, t) {
  i18nCallBack();
});

var i18nCallBack = function(){
  fillLanguage();
  var header = header || {};
  header["Accept"] = "application/json, text/javascript, */*; q=0.01";
  // set some defaults for Ajax calls
  $.ajaxSetup({
    cache: false,
	headers:header,
    beforeSend: function () {
      pg.ui.spinnerPointer(true);
    },
    complete: function (e, message, jqxhr, opts) {
      pg.ui.spinnerPointer(false);
    },
    contentType: 'application/json',
    statusCode: {
      0: function () {
        if (pg.state.applicationLaunched) {
          pg.dialog.agentAbsent();
        }
        pg.ui.enableTransferButtons();
      },
      500: function (xhr) {
        if (pg.state.applicationLaunched && !pg.state.dontThrowConnectionError) {
          pg.dialog.errorConnectingRemote(xhr.responseText);
        }
        pg.state.dontThrowConnectionError = false;
        pg.ui.enableTransferButtons();
      }
    }
  });

  var lang = pgLanguage[pg.config.webapp.language];

  // Value is generated by FileCatalyst BUILD script (unlimited.core.util.VersionSearchAndReplace.java) and should not
  // be modified.
  // (version/status/build) status 1=ALPHA,2=BETA,3=PRODUCTION
    pg.version= "3.7.2 3 7";//(version/status/build) status 1=ALPHA,2=BETA,3=PRODUCTION

  // pg.ta will store the retrieved TA settings
  pg.ta = pg.ta || {
    "http.port": {
      value: pg.config.localAgent.portDefault,
      type: "INTEGER"
    }
  };
  pg.erroredFiles = [];
  pg.successFiles = [];
  /**
   * A malleable object storing a number of quasi-global (within the PG namespace
   * but publicly accessible) flags and application states
   *
   * @type {object}
   * @memberOf pg
   * @property {integer} detectRequests - stores a count of requests made by pg.rest.connect
   * @property {integer} confirmAttempts - stores a count of number of times a 'confirm' dialog has appeared
   */
  pg.state = {
    detectRequests: 0,
    confirmAttempts: 0,
    validCreds: null,
    pollHeartbeat: true,
    dontThrowConnectionError: false,
    lastErrorConnectionMessage: "",
    requestingConnection: false,
    //added this flag to avoid pg.init.remoteFiles() been called twice (provoking two connection request)
    remoteFilesIntialRequest: false,
    //added this flag to avoid pg.init.localFiles() been called twice (provoking two connection request)
    localFilesIntialRequest: false,
    // REST CALL rs/agent/serviceStatus -> serviceRunning save info. (default false)
    isRunningAsService: false
  };

  // create some empty containers for the states of remoteNodes
  for (var key in pg.config.remoteNodes) {
    pg.state[key] = {};
    pg.state[key].manualConfig = false;
  }

  /**
   * An object containing two predefined icon sets (using Font Awesome and the Glyphicons included in Bootstrap3),
   * as well as a string defining which set to use and a getter for returning the requested icon from the current set.
   *
   * @type {object}
   * @memberOf pg
   * @property {string} currentset - a string found in pg.config.webapp.iconSet.
   * @property {object} fontawesome - HTML (strings with classes) to render Font Awesome icons
   * @property {object} glyphicons - HTML (strings with classes) to render Bootstrap3 glyphicons halflings
   * @property {function} get - returns an icon from the current set matching the passed key
   */
  pg.icon = {
    currentset: pg.config.webapp.iconSet,
    fontawesome: {
      default: '<i class="fa fa-question-circle"></i>',
      directory: '<i class="fa fa-folder"></i>',
      file: '<i class="fa fa-file-o"></i>',
      upload: '<i class="fa fa-upload"></i>',
      download: '<i class="fa fa-download"></i>',
      checkedbox: '<i class="fa fa-check-square-o"></i>',
      uncheckedbox: '<i class="fa fa-square-o"></i>',
      trash: '<i class="fa fa-trash-o"></i>',
      levelup: '<i class="fa fa-level-up"></i>',
      settings: '<i class="fa fa-gears"></i>',
      more: '<i class="fa fa-plus-square-o"></i>',
      less: '<i class="fa fa-minus-square-o"></i>',
      addqueue: '<i class="fa fa-arrow-circle-right"></i>',
      envelope: '<i class="fa fa-envelope"></i>',
      ok: '<i class="fa fa-check"></i>',
      remove: '<i class="fa fa-times"></i>',
      repeat: '<i class="fa fa-repeat"></i>',
      refresh: '<i class="fa fa-refresh"></i>',
      spinner: '<i class="fa fa-spinner fa-spin"></i>',
      home: '<i class="fa fa-home"></i>',
      desktop: '<i class="fa fa-desktop"></i>',
      documents: '<i class="fa fa-files-o"></i>',
      downloads: '<i class="fa fa-download"></i>'
    },
    glyphicons: {
      default: '<span class="glyphicon glyphicon-question-sign"></span>',
      directory: '<span class="glyphicon glyphicon-folder-close"></span>',
      file: '<span class="glyphicon glyphicon-file"></span>',
      upload: '<span class="glyphicon glyphicon-upload"></span>',
      download: '<span class="glyphicon glyphicon-download"></span>',
      checkedbox: '<span class="glyphicon glyphicon-check"></span>',
      uncheckedbox: '<span class="glyphicon glyphicon-unchecked"></span>',
      trash: '<span class="glyphicon glyphicon-trash"></span>',
      levelup: '<span class="glyphicon glyphicon-arrow-up"></span>',
      settings: '<span class="glyphicon glyphicon-cog"></span>',
      more: '<span class="glyphicon glyphicon-plus-sign"></span>',
      less: '<span class="glyphicon glyphicon-minus-sign"></span>',
      addqueue: '<span class="glyphicon glyphicon-circle-arrow-right"></span>',
      envelope: '<span class="glyphicon glyphicon-envelope"></span>',
      ok: '<span class="glyphicon glyphicon-ok"></span>',
      remove: '<span class="glyphicon glyphicon-remove"></span>',
      repeat: '<span class="glyphicon glyphicon-repeat"></span>',
      spinner: '<span class="glyphicon glyphicon-asterisk fa-spin"></span>',
      home: '<span class="glyphicon glyphicon-home"></span>',
      desktop: '<span class="glyphicon glyphicon-modal-window"></span>',
      documents: '<span class="glyphicon glyphicon-duplicate"></span>',
      downloads: '<span class="glyphicon glyphicon-download-alt"></span>'
    },
    /**
     * Returns requested icon markup as a string
     *
     * @memberOf pg.icon
     * @param {string} icon - a valid property (key) of the current icon set object. See
     * pg.icon.fontawesome or pg.icon.glyphicons for a sample list
     * @returns {string}
     */
    get: function (icon) {
      var set = pg.icon[pg.icon.currentset];
      var theicon = set[icon];
      return theicon;
    }
  };

  // allow icons to be defined in the configuration.js file (or elsewhere) with
  // an object named pg.config.webapp.customIcons
  if (typeof (pg.config.customIcons !== "undefined")) {
    $.extend(pg.icon, pg.config.customIcons);
  }

  // collection of utilities used by the application
  pg.utils = {
    detectOS: function () {
      var os = "linux";
      var agent = navigator.userAgent || ""; // if undefined, make an empty string which will result in Linux/Other
      agent = agent.toLowerCase();
      if (agent.indexOf("mac") > -1) {
        os = "mac";
      } else if (agent.indexOf("windows") > -1) {
        os = "windows";
      }
      return os;
    },
    validateEmail: function (email) {
      var re =
          /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
      return re.test(email);
    },
    getEmails: function () {
      if ($(".pure-email").length === 0) {
        return "";
      }
      var emailList = "";
      $.each($(".pure-email.valid"), function (i, v) {
        emailList += $(v).html() + ";";
      });
      return emailList;
    },
    processDoAfter: function (doAfter, data) {
      // first thing to do is stop the warning that comes from navigating away from the page
      window.onbeforeunload = null;

      function confirm(doAfter) {
        if ((typeof (doAfter) === "string" && doAfter.length > 0) || typeof (doAfter) === "function") {
          return doAfter;
        } else {
          return pg.config.webapp.doAfterTransfer;
        }
      }

      doAfter = confirm(doAfter);

      // doAfter is one of "doAfterSuccess", "doAfterError", "doAfterCancel", "doAfterOtherError", "doAfterTransfer"
      // depending on the finalization type, one of these will be invoked IF SET. Otherwise nothing
      if (typeof (doAfter) === "string" && doAfter.length > 0) {
        window.location = doAfter;
      } else if (typeof (doAfter) === "function") {
        doAfter(data);
      }
    },
    confirmOnPageExit: function (e) {
      // If we haven't been passed the event get the window.event
      e = e || window.event;
      var message = lang.warningOnNavigate;

      // For IE6-8 and Firefox prior to version 4
      if (e) {
        e.returnValue = message;
      }

      // For Chrome, Safari, IE8+ and Opera 12+
      return message;
    },
    mergeStringArray: function (a, b) {
      // this function accepts two arrays of strings and de-duplicates them. Merges two
      // arrays of strings into one master array of strings.

      if ($.isArray(a) === false || $.isArray(b) === false) {
        return "err";
      }

      var hash = {};
      var ret = [];

      for (var i = 0; i < a.length; i++) {
        var e = a[i];
        if (!hash[e]) {
          hash[e] = true;
          ret.push(e);
        }
      }

      for (var i = 0; i < b.length; i++) {
        var e = b[i];
        if (!hash[e]) {
          hash[e] = true;
          ret.push(e);
        }
      }
      return ret;
    },
    parseQuery: function (theQuery) {
      /* Utility for parsing query strings. To parse directly from address bar,
       * theQuery should be window.location.search.substring(1); the fc.urlParams
       * does this already and is available on all pages. Otherwise, theQuery is any
       * string that resembles a query string (url?var=foo&another=bar)
       */

      // only proceed if there are any parameter=value pairs, denoted by a "=" in the query.
      if (theQuery.indexOf('=') === -1) {
        return {};
      }

      // drop the hostname
      if (theQuery.indexOf('?') > -1) {
        var temp = theQuery.split('?');
        theQuery = temp[1];
      }

      var exec,
              space = /\+/g, // Regex for replacing addition symbol with a space
              regex = /([^&=]+)=?([^&]*)/g,
              decodedQuery = {},
              decode = function (s) {
                return decodeURIComponent(s.replace(space, " "));
              };

      while (exec = regex.exec(theQuery)) {
        decodedQuery[decode(exec[1])] = decode(exec[2]);
      }
      return decodedQuery;
    },
    cookieObjStore: function (cookieName, obj) {
      if ($.isPlainObject(obj)) {
        $.cookie(cookieName, JSON.stringify(obj), {expires: 365});
      }
      // return original object for chaining
      return obj;
    },
    cookieObjGet: function (cookieName) {
      var cookie = $.cookie(cookieName);
      try {
        cookie = $.parseJSON(cookie);
      } catch (e) {
        // leave cookie alone
      }
      return cookie;
    },
    connectionKeyFromId: function (id) {
      var connectionKey = "unknown";
      var serverId;
      if (id in pg.config.downloadButtons) {
        serverId = pg.config.downloadButtons[id].sourceId;
      } else {
        serverId = id;
      }
      for (var key in pg.storedNodes) {
        var thisNode = pg.storedNodes[key];
        if (thisNode.id === serverId) {
          connectionKey = thisNode.connectionKey;
        }
      }
      return connectionKey;
    },
    getNodeInfo: function (jQo) {
      var key = jQo.closest('.componentContainer').data('connectionKey');
      var node = pg.storedNodes[key];
      var nodeInfo = {
        key: key,
        node: node
      };
      return nodeInfo;
    },
    createBundle: function (jQo) {
      var bundle = {};
      var infoObj = pg.getRowInfo(jQo);
      if (!jQo.hasClass('initialdir')) {
        var thisPath = infoObj.fileSet[infoObj.filePos].path;
        bundle.path = pg.utils.normalizePath(thisPath);
      }
      bundle._package = pg.storedNodes[infoObj.connectionKey];
      return bundle;
    },
    createPackage: function (id, connectionKey, $elems) {
      return {id: id, connectionKey: connectionKey, $elems: $elems};
    },
    storeNode: function (params) {
      pg.storedNodes = pg.storedNodes || {};
      pg.storedNodes[params.connectionKey] = params;
    },
    baseUrl: function (service, port, helpUrl) {
      // accepts a string representing the REST service required; also accepts
      // an object; if an object is passed in, the service is assumed to be "transfer"
      if (typeof (port) === "undefined") {
        if (typeof (pg.ta['http.port']) !== "undefined") {
          port = pg.ta['http.port'].value;
        } else {
          port = pg.config.localAgent.portDefault;
        }
      }
      if (typeof (service) === "object") {
        var node = service;
        var key = node.connectionKey;
        if (key === "local") {
          service = 'transfer';
        } else {
          // for now, the service is always transfer
          // the else block is reserved for future changes
          service = 'transfer';
        }
      }

      // sanitize the service input as much as possible
      service = service.trim();
      var serviceArray = service.split('/');
      for (var en = 0; en < serviceArray.length; en++) {
        serviceArray[en] = encodeURIComponent(serviceArray[en]);
      }
      service = serviceArray.join('/');

      var filesUrls = ['local', 'remote', 'transfer', 'transfer/cancel', 'local/filter', 'transferRev1'];
      var agentUrls = ['config', 'heartbeat', 'status', 'version', 'connect', 'reveal', 'register', 'serviceStatus'];
      if ($.inArray(service, filesUrls) >= 0) {
        service = "files/" + service;
      } else if ($.inArray(service, agentUrls) >= 0) {
        service = "agent/" + service;
      }
      var url = pg.config.localAgent.host + ":" + port;
      try {
        //for central use -> protocol + ip + + ":" + port + "/rs/nodes/" + nodeID + "/ta"
        if (parseInt(centralNewHost.nodeID) > 0) {
          url =
              centralNewHost.protocol + centralNewHost.ip + ":" + centralNewHost.port + "/rs/nodes/"
              + centralNewHost.nodeID + "/ta/";
        }
      } catch (e) {
        console.error(e);
      }
      if (helpUrl !== undefined) {
        // Check again because I cannot change the core function without change other kind of use of TA deployment
        // - Dirceu Nazareth
        if (parseInt(centralNewHost.nodeID) > 0) {
          return url;
        } else {
          return url + "/";
        }
      }
      if (typeof (service) !== "undefined" && centralNewHost.nodeID === 0) {
        url += "/rs/" + service;
      } else {
        url += service;
      }
      return url;
    },
    updateConfig: function (name, value, type) {
      // run some basic sanity checks
      if (typeof (type) === "undefined") {
        type = "STRING"; // set a default
      }
      if (type !== "INTEGER" && type !== "BOOLEAN" && type !== "STRING" && type !== "LONG") {
        type = "STRING";
      }
      if (typeof (value) === "undefined") {
        value = null; // there cannot be a default value
      }
      if (typeof (name) !== "string") {
        name = name.toString;
      }
      if (typeof (pg.ta) === "undefined") {
        pg.ta = {};
      }

      // custom function tailored specifically for reading values stored in
      // the ta (TransferAgent) object. Not a general-purpose cookie reader/writer
      // use $.cookie for general purpose.
      pg.ta[name] = {
        value: value,
        dataType: type
      };
      pg.utils.paramSetCookie(pg.ta);
      return pg.ta[name];
    },
    jqWrap: function ($node) {
      if ($node instanceof HTMLElement) {
        $node = $($node);
      }

      return $node;
    },
    getLinkForOS: function (kindOfLink, os) {
      // although this function should usually be called without passing in an os,
      // you are able to explicitly pass "Windows", "Mac", or "Linux" to bypass detection.
      // let's normalize the case:
      if (typeof os === "string") {
        os = os.toLowerCase();
      }
      
      var linkMap = {
        download: {
          windows: pg.config.webapp.appDownloadLinkWindows,
          mac: pg.config.webapp.appDownloadLinkMac,
          linux: pg.config.webapp.appDownloadLinkLinux
        },
        installDoc: {
          windows: lang.docWindowsLocation,
          mac: lang.docMacLocation,
          linux: lang.docLinuxLocation
        }
      };
      
      // if the kindOfLink ("download" or "installDoc") is not provided, assume we are
      // after the installDoc
      kindOfLink = kindOfLink ? kindOfLink : "installDoc";
      
      // only detect if os is not explicitly passed in with the params
      if (typeof (os) === "undefined" || (os !== "mac" && os !== "windows" && os !== "linux")) {
        os = pg.utils.detectOS();
      }

      // set the link with best-known results
      var theLink = linkMap[kindOfLink][os];
      return theLink;
    },
    registerInstalled: function () {
      pg.localConfig = pg.localConfig || {};
      pg.localConfig.agentInstalled = true;
      $.cookie('filecatalystLocalConfig', JSON.stringify(pg.localConfig), {expires: 365});
      return pg.localConfig.agentInstalled;
    },
    objectLength: function (object) {
      function ObjectLength_Modern(object) {
        return Object.keys(object).length;
      }

      function ObjectLength_Legacy(object) {
        var length = 0;
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            ++length;
          }
        }
        return length;
      }

      if (typeof (object) === "object") {
        var theLength = object.keys ? ObjectLength_Modern(object) : ObjectLength_Legacy(object);
        return theLength;
      } else {
        return 0; // warning: this means that undefined objects will still return 0 instead of "undefined"
      }
    },
    normalizePath: function (string) {
      var path = string.replace(/\\/g, "/");
      var pathArray = path.split("/");
      var encodedPath = "";
      for (var i = 0; pathArray.length > i; i++) {
        var part = pathArray[i];
        encodedPath += encodeURIComponent(part) + "/";
      }
      if (path.charAt(0) === "/" && encodedPath.charAt(0) !== "/") {
        encodedPath = "/" + encodedPath;
      }
      return encodedPath;
    },
    stripChars: function (string) {
      // cast to string
      string = "" + string;

      // removes all special characters; typically used for HTML property names where special characters are disallowed
      var stripped = string.replace(/[^\w\s]/gi, '');
      return stripped;
    },
    receiveObj: function (event) {
      // the object MUST have this format for the message to be useful:
      // {name: "tester",
      //  contents: {
      //    anything: "anything",
      //    func:{
      //      alerter:function(){
      //        alert('A function was posted up!')
      //      }
      //    },
      //    somethingelse: "somethingelse"
      //  }
      // }
      //
      // The object becomes pg[name] with the value being the object found at [contents]
      // *** if functions are passed, they must be in an object called 'func' within 'contents'
      function makeFunctions(obj) {
        for (var key in obj) {
          obj[key] = eval('(' + decodeURI(obj[key]) + ');');
        }
      }

      if (event.origin !== pg.config.localAgent.host + ":" + pg.ta['http.port'].value)
        return;
      if (typeof (event.data) === "object") {
        if (event.data.name === "taParameters") {
          pg.config.taParameters = event.data.contents;
          $.cookie('taParameters', JSON.stringify(pg.config.taParameters), {expires: 365});
        } else {
          pg[event.data.name] = event.data.contents;
          if (pg[event.data.name].func) {
            makeFunctions(pg[event.data.name].func);
          }
        }
      }
    },
    splitString: function (string, delim) {
      if (typeof (delim) === "undefined") {
        delim = "-";
      }

      return string.substring(string.indexOf(delim) + 1);
    },
    notifybox: function (message, target, classStr) {
      var $box = $('#notifybox');
      if ($box.length <= 0) {
        $box = $('<div id="notifybox"/>');
      }
      target.after($box);
      var maxMsg = 5;
      var $thisMessage = $('<div class="alert alert-' + classStr + '">' + message + '</div>');
      if ($box.find('div.alert').length >= maxMsg) {
        $box.find('div.alert:last').remove();
        $box.prepend($thisMessage);

      } else {
        $box.prepend($thisMessage);
      }
      setTimeout(function () {
        $thisMessage.fadeOut(500, function () {
          $thisMessage.remove();
        });
      }, pg.utils.notifications.defaults.delay);
      return $box;
    },
    calculateOffset: function (selector, added) {
      var scrolled = $('body').scrollTop();
      var selectorHeight = $(selector).outerHeight();
      var height = 0;
      if (typeof (selector) === "undefined") {
        return 0;
      }
      if (typeof (added) === "undefined") {
        added = 20;
      }
      height = selectorHeight - scrolled;
      if (scrolled > selectorHeight) {
        height = 0;
      }
      height = height + added;
      if (isNaN(height)) {
        height = 0;
      }
      return height;
    },
    sizeConvert: function (bytes) {
      // based on input bytes, returns an object with useful conversion information
      bytes = parseInt(bytes);
      if (isNaN(bytes)) {
        bytes = "unknown";
      }

      var i = 0;
      var sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      var converted = {
        size: "" + bytes,
        unit: sizes[0],
        string: bytes + " B",
        original: bytes + " bytes"
      };

      if (bytes > 0 && bytes >= 1024 && bytes !== "unknown") {
        do {
          bytes /= 1024;
          ++i;
        } while (bytes >= 1024);
        if (i > 1) {
          bytes = bytes.toFixed(1);
        } else {
          bytes = Math.round(bytes);
        }

        converted.size = "" + bytes;
        converted.unit = sizes[i];
        converted.string = bytes + " " + converted.unit;
      }
      return converted;
    },
    timeConvert: function (type, value) {
      /* type must come in as one of: "hhmmss", "date-hhmmss", "numerical-hhmm" */
      var convertedTime;

      // utility function to add zeroes as needed (used later in script)
      function checkTime(i) {
        if (i < 10)
        {
          i = "0" + i;
        }
        return i;
      }

      // when value is -1, we are viewing a "monitoring" task; return a string
      if (parseInt(value, 10) < 0) {
        convertedTime = "monitoring";
      }

      // otherwise, let's continue processing the time
      else {
        // make sure we're in base-ten
        value = parseInt(value, 10);

        if (type === "date") {
          // format as a date; code not written yet
        } else if (type === "hhmmss" || type === "date-hhmmss" || type === "numerical-hhmm") {
          // format as a time in HH:MM:ss

          var rawTime = new Date(value);
          if (rawTime.getTime() > 0 === false) {
            return "err";
          }
          var month = lang.months;

          var
                  y = rawTime.getFullYear(),
                  mo = rawTime.getMonth(),
                  d = rawTime.getUTCDate(),
                  h = rawTime.getHours(),
                  m = rawTime.getMinutes(),
                  s = rawTime.getSeconds(),
                  // add a zero in front of numbers<10
                  m = checkTime(m);
          s = checkTime(s);

          if (type === "hhmmss") {
            convertedTime = h + ":" + m + ":" + s;
          } else if (type === "numerical-hhmm") {
            mo++;
            convertedTime = y + '-' + checkTime(mo) + '-' + checkTime(d) + ' ' + checkTime(h) + ':' + m;
          } else {
            mo = month[rawTime.getMonth()];
            convertedTime = mo + " " + d + " " + h + ":" + m;
          }

        } else {
          return "err";
        }
      }
      return convertedTime;
    },
    durationConvert: function (millis, format) {
      // some conditions may cause millis to be passed through without processing.
      // initialize this variable for later use;
      var passthrough = false;

      var validFormats = ["hhmmss", "phrase"];
      if (typeof format === "undefined" || validFormats.indexOf(format) === -1) {
        // set the default format
        format = "hhmmss";
      }
      if (typeof millis === "undefined") {
        millis = 0;
      }

      if (typeof millis === "string") {
        passthrough = true;
      }

      if (!passthrough) {
        // Modified from code at http://stackoverflow.com/questions/19700283/how-to-convert-time-milliseconds-to-hours-min-sec-format-in-javascript
        function msToTime(duration) {
          var milliseconds = parseInt((duration % 1000) / 100)
                  , seconds = parseInt((duration / 1000) % 60)
                  , minutes = parseInt((duration / (1000 * 60)) % 60)
                  , hours = parseInt((duration / (1000 * 60 * 60)) % 24);

          hours = (hours < 10) ? "0" + hours : hours;
          minutes = (minutes < 10) ? "0" + minutes : minutes;
          seconds = (seconds < 10) ? "0" + seconds : seconds;

          return {
            hours: hours,
            minutes: minutes,
            seconds: seconds,
            milliseconds: milliseconds
          };
        }

        var converted = msToTime(millis);
        var final = "unknown";

        if (format === "hhmmss") {
          final = "" + converted.hours + ":" + converted.minutes + "." + converted.seconds;
        } else if (format === "phrase") {
          final = "" + converted.hours + " " + i18n.t("webDeployment.hoursLabel") + " "
                  + converted.minutes + " " + i18n.t("webDeployment.minutesLabel") + " "
                  + converted.minutes + " " + i18n.t("webDeployment.secondsLabel");
        }
        return final;
      }
      return millis;
    },
    dialog: function (message, opts) {
      var modal = undefined;
      if (typeof (message) === "object" && typeof (opts) === "undefined") {
        opts = message;
      }

      if (typeof (opts) === "undefined") {
        modal = bootbox.alert(message);
      } else {
        if (typeof (opts.message) === "undefined" || opts.message === null || opts.message === "") {
          opts.message = message;
        }
        // sanity check for existing identical dialog
        if (opts.className) {
          var $dialog = $('.' + opts.className);
          if ($dialog.length > 0) {
            var $body = $dialog.find('.modal-body>div');
            if ($body.find('.dialogWarning').length <= 0) {
              $body.prepend('<p class="alert alert-danger dialogWarning"><em>' + lang.retryDialogMsg + '</em></p>');
            } else {
              var $numWarns = $body.find('.dialogRepeats');
              if ($numWarns.length <= 0) {
                $body.find('.dialogWarning').prepend('(<span class="dialogRepeats">2</span>)');
              } else {
                var currentVal = parseInt($numWarns.text());
                currentVal++;
                $numWarns.text(currentVal);
              }
            }
          } else {
            modal = bootbox.dialog(opts);
          }
        }
      }

      // Returning reference to the modal we've created, so we don't have to look for it later.
      // Since this happens every time the modal is opened, the hook is self-updating.
      return modal;
    },
    paramToObj: function (array) {
      var tmpObj = {};
      if ($.isArray(array)) {
        for (var i = 0; i < array.length; i++) {
          var thisObj = array[i];
          if (thisObj.hasOwnProperty("name")) {
            var theValue = thisObj.hasOwnProperty("value") ? thisObj.value : null;
            var theDataType = thisObj.hasOwnProperty("dataType") ? thisObj.dataType : null;
            tmpObj[thisObj.name] = {"value": theValue, "dataType": theDataType};
          }
        }
      }
      return tmpObj;
    },
    paramToArr: function (obj) {
      var tmpArr = [];
      var index = 0;

      if ($.isPlainObject(obj)) {
        for (var key in obj) {
          tmpArr[index] = {};
          tmpArr[index].name = key;
          tmpArr[index].value = obj[key].value;
          tmpArr[index].dataType = obj[key].dataType;
          index++;
        }
      }
      return tmpArr;
    },
    paramSetCookie: function (configObj) {
      // custom function tailored specifically for reading values stored in
      // the ta (TransferAgent) object. Not a general-purpose cookie reader/writer
      // use $.cookie for general purpose.
      var paramArray = pg.utils.paramToArr(configObj);
      $.cookie('taParameters', JSON.stringify(paramArray), {expires: 365});
    },
    paramGetCookie: function () {
      // custom function tailored specifically for reading values stored in
      // the ta (TransferAgent) object. Not a general-purpose cookie reader/writer
      // use $.cookie for general purpose.
      var paramArray = $.parseJSON($.cookie('taParameters'));
      return paramArray;
    },
    resetLocalStorage: function () {
      $.cookie('taParameters', null);
      $.cookie('filecatalystLocalConfig', null);
    },
    getHeartbeat: function (port, successHandler, errorHandler) {
      if (typeof (successHandler) === "undefined") {
        successHandler = function () {
        };
      }
      if (typeof (errorHandler) === "undefined") {
        errorHandler = function () {
        };
      }

      var url = pg.utils.baseUrl('heartbeat', port);
      var timeoutcall = 0;
      var browser = window.browserInfo.browser;
      if (browser.indexOf('firefox') > -1) {
        timeoutcall = 1000;
      }

      $.ajax({
        url: url,
        method: 'GET',
        async: true,
        timeout: timeoutcall,
        beforeSend: function () {
          // empty function to override default pointer spinner
        },
        success: function (data) {
          // needs refactor; should not be adding to a successHandler; those should stand alone
          var $manualDialog = $('.modal-manualLaunch');
          if ($manualDialog.length > 0) {
            $manualDialog.modal('hide');
          }
          pg.state.applicationLaunched = true;
          pg.utils.updateConfig("http.port", port, "INTEGER");
          pg.utils.registerInstalled();
          pg.state.rememberLaunchChoicePending = true;
          pg.status.transferAgent.launchAutomatically();
          pg.ui.spinnerScreen(false, "heartbeat");
          pg.ui.spinnerScreen(false, "launch");
          pg.ui.spinnerScreen(false, "initializing");
          pg.status.transferAgent.reset();
          successHandler(data);
        },
        error: function (data) {
          errorHandler(data);
        },
        statusCode: {
          0: function () {
          }
        }
      });
    },
    launchAndHeartbeat: function (params) {
      if (pg.localConfig.launchAutomatically) {
        pg.init.launchApplication();
      } else {
        if (!pg.state.launchAttempted && $(".modal-manualLaunch").length < 1 && !params.ignoreManualLaunch) {
          pg.dialog.manualLaunch();
        }
      }

      params.port = pg.ta['http.port'].value || params.port;

      function attempt() {
        pg.utils.getHeartbeat(params.port, params.success, params.error);
      }

      var browser = window.browserInfo.browser;
      browser = browser.toLowerCase();
      if (browser.indexOf('explorer') === -1) {
        attempt();
      } else {
        if (typeof (pg.localConfig) !== "undefined")
          if (typeof (pg.localConfig.agentInstalled) !== "undefined" && pg.localConfig.agentInstalled) {
            attempt();
          } else {
            if (!pg.state.launchAttempted && $(".modal-manualLaunch").length < 1 && !params.ignoreManualLaunch) {
              pg.dialog.manualLaunch();
            }
            attempt();
          }
      }
    },
    revealPath: function (path) {
      // do the reveal only if a path is passed in
      var callBack = function () {
        pg.utils.revealPath(path);
      };
      if (typeof (path) !== "undefined" && typeof (path) === "string") {
        var url = pg.utils.baseUrl('reveal') + "?target=";
        url += encodeURIComponent(path);
        $.ajax({
          url: url,
          method: 'GET',
          success: function (returnData) {
            // no handler currently needed
          },
          error: function (xhr, opts, error) {
            pg.state.applicationLaunched = false;
            pg.state.launchAttempted = false;
            pg.utils.checkAndRelaunchTA(callBack);
            console.error(error);
          }
        });
      }
    },
    /**
     * Checks to see if the application needs to be updated.
     *
     * @param  {Object}     transferAgentVersion 
     *                                         The object containing the version data we're checking as retrieved from
     *                                         the TA.
     * @param  {string}     webApplicationVersion
     *                                         The version string reported by the web application as a basis of
     *                                         comparison to the TransferAgent itself.     
     * @return {number|NaN}                    The result of the version check. Is -1 when the version given is older
     *                                         than the current version. Is 1 when the version given is newer than the
     *                                         current version. Is 0 when the version given is the same as the current
     *                                         version. It is NaN if the version given is invalid.
     */
    compareVersion: function (transferAgentVersion, webApplicationVersion) {
      //check if the user declined the upgrade for this version.
      if (localStorage.getItem('webLink.VersionFoundWhenUserDeclinedUpdate') === webApplicationVersion)
        return;

      var intCurrentFile = 0;
      var fileVersionArray = [];
      var dataVersionArray = [];
      var versionDepth = 0;
      var result = NaN;

      //current version in this file
      var splitFileVersion = webApplicationVersion.split(' ');

      if (splitFileVersion[ 0 ] === 'Enterprise') {

        var tempStatus = splitFileVersion[ 2 ];
        splitFileVersion = splitFileVersion[ 1 ].replace('v', '').split('.');
        splitFileVersion = [splitFileVersion[ 0 ] + '.' + splitFileVersion[ 1 ], tempStatus, splitFileVersion[ 2 ]];
      }

      // Make arrays out of version strings:
      fileVersionArray = splitFileVersion[ 0 ].split('.');
      dataVersionArray = transferAgentVersion.version.split('.');

      // Make sure the arrays are the same length
      versionDepth = fileVersionArray.length;
      if (dataVersionArray.length > versionDepth) {

        versionDepth = dataVersionArray.length;
      }

      // Converting legacy status version name to status version number
      try {

        intCurrentFile = parseInt(splitFileVersion[ 1 ]);

        if (isNaN(intCurrentFile)) {

          switch (splitFileVersion[ 1 ].toUpperCase()) {

            case 'ALPHA':

              intCurrentFile = 1;
              break;

            case 'BETA':

              intCurrentFile = 2;
              break;

            case 'PRODUCTION':
            case 'ENTERPRISE':

              intCurrentFile = 3;
              break;

            default:

              intCurrentFile = 0;
          }
        }
      } catch (e) {

        intCurrentFile = 0;
      }

      // Add the status version number to the arrays.
      fileVersionArray[ versionDepth ] = intCurrentFile;
      dataVersionArray[ versionDepth ] = transferAgentVersion.statusInt;

      // Add the build version number to the arrays.
      fileVersionArray.push(parseInt(splitFileVersion[ 2 ]));
      dataVersionArray.push(transferAgentVersion.build);

      // Go through each version number and see how they compare
      $.each(fileVersionArray, function (index, currentValue) {

        // We sanitize each value into a good integer
        var fileVersionNumber = parseInt(currentValue) || 0;
        var dataVersionNumber = parseInt(dataVersionArray[ index ]) || 0;

        // If the file version is larger than the version we passed to this function
        if (fileVersionNumber > dataVersionNumber) {

          result = -1;
          return false;

          // If the file version is smaller than the version we passed to this function
        } else if (fileVersionNumber < dataVersionNumber) {

          result = 1;
          return false;

          // If the file version is the same as the version we passed to this function
        } else {

          result = 0;
        }
      });

      // Return the results of our comparison.
      return result;
    },
    /**
     * Stores the introduction of new or changed API methods
     * 
     * @param {string} taVersion
     */
    apiChecks: function (taVersion) {
      pg.available = pg.available || {};
      pg.available.statusViaGet = pg.utils.compareVersion(taVersion, "3.6 Beta 5") >= 0 ? true : false;
      pg.available.serviceStatus = pg.utils.compareVersion(taVersion, "3.7 Beta 1") >= 0 ? true : false;
    },
    checkAndRelaunchTA: function (callBack) {
      pg.utils.launchAndHeartbeat({
        //PORT
        port: pg.config.localAgent.portDefault,
        //SUCCESS CALL
        success: function () {
          pg.ui.spinnerScreen(false, "heartbeat");
          pg.ui.spinnerScreen(false, "waiting");
          pg.state.dontThrowConnectionError = true;
          if (callBack) {
            callBack();
          }
        },
        //ERROR CALL
        error: function () {
          var callBackSecondScope = function () {
            pg.utils.checkAndRelaunchTA(callBack);
          };

          if (! pg.state.launchAttempted ) {
            pg.init.launchApplication();
          }
          setTimeout(callBackSecondScope, 3000);
        },
		//FLAG TO NO EVOKE MANUAL LAUNCH DIALOG
		ignoreManualLaunch:true
      });
    },
    commonConnectionErrors: function (responseText, longError) {
      var errorMsg = false;
      if (typeof (responseText) !== "undefined") {
        responseText = responseText.toLowerCase();
        if (responseText.indexOf('unsupported client') > -1 || responseText.indexOf('2-way applet') > -1) {
          var noLicense = longError ? 'errorNotLicensedMsg' : 'errorNotLicensedMsgShort';
          errorMsg = '<p>' + lang[noLicense] + '</p>';
        }
        if (responseText.indexOf('invalid origin') > -1) {
          var noLicense = longError ? 'errorInvalidOrigin' : 'errorInvalidOriginShort';
          errorMsg = '<p>' + lang[noLicense] + '</p>';
        }
        if (responseText.indexOf('license is expired') > -1) {
          var noLicense = longError ? 'errorServerExpiredMsg' : 'errorServerExpiredMsgShort';
          errorMsg = '<p>' + lang[noLicense] + '</p>';
        }
      }
      return errorMsg;
    },
    launchPopover: function(){
        $('[data-toggle="popover"]').popover();
        var elementPopover = "pg.utils.closePopover('iconRemoveCredentials')";
        var contentPopover =
            '<button class="btn btn-sm btn-success" onclick="pg.utils.removeSavedLogin()">'
            + lang.tooltips.yes + '</button><button class="btn btn-sm btn-primary" onclick="'
            + elementPopover + '">' + lang.tooltips.no + '</button>';
        $("#iconRemoveCredentials").popover({
          title: lang.tooltips.removeCredentialsWarning,
          content: contentPopover,
          html: true,
          placement: "bottom"
        });
    },
    verifyStatusOfTransfers: function(key){
        var url = pg.utils.baseUrl('status');
        $.ajax({
            url: url,
            type: "GET",
            dataType: 'json',
            success: function (data) {
                if(data && data.allTransfers && data.allTransfers.length>0){
                    for(var i = 0; data.allTransfers.length>i; i++){
                        var currentTransfer = data.allTransfers[i];
                        var direction = currentTransfer.transferDirection;
                        if(
                            (direction === "UPLOAD" && $(".listArea").data("connectionKey") === "local")
                            || (direction !== "UPLOAD" && $(".listArea").data("connectionKey") !== "local")
                        ){
                            if(currentTransfer.connectionKey === key){
                                var target =  direction === "UPLOAD" ? key : "local";
                                var sourceNode = {
                                    connectionKey: key,
                                    activeTarget: target,
                                    activeJobId : currentTransfer.transferID,
                                    $elems: {
                                        container: $(".listArea"),
                                        controls: $(".ta-controls"),
                                        currentTable: $("table.statusFields"),
                                        queue: $(".ta-queue"),
                                        list: $(".ta-list"),
                                        info: $(".ta-info"),
                                        email: $(".ta-email"),
                                        infoOverall: $("td.overallStatus"),
                                        infoCurrent: $("td.currentStatus")
                                    },
                                    id: $(".listArea").attr("id")
                                };
                                var transferData = {
                                    jobId: currentTransfer.transferID,
                                    DestinationConnectionKey: target,
                                    remoteDirectory: currentTransfer.targetDirectory
                                };
                                pg.poll.execute(transferData, sourceNode);
                            }
                        }
                    }
                }
            }
        });
    },
    checkRunningAsService: function(successCallback, errorCallback){
        var url = pg.utils.baseUrl('serviceStatus');

        $.ajax({
            url: url,
            type: "GET",
            dataType: 'json',
            success: function(data){
                if(successCallback){
                    successCallback(data);
                }
            },
            error: function(xhr){
                if(errorCallback){
                    errorCallback(xhr);
                }
            }
        });
    },
    runningAsServiceStatusGetSet : function(data){
        if(data){
            pg.state.isRunningAsService = data.serviceRunning;
        }else{
            return pg.state.isRunningAsService;
        }
    }
  };

  // functions used to ensure creation of required DOM elements
  pg.ensure = {
    widgets: function (id_string) {
      /**
       * All dynamically-rendered widgets are selected by div ID. These divs are ideally
       * already found in the markup, but if they are not, they are created on
       * the fly. pg.uploadButton.widgets() checks for and creates any missing divs based
       * on local listing (hard coded) and remote nodes (user provided in pg.config.remoteNodes

       * If subcomponents (the list, controls, queue, and progress/info panel) are not found
       * in the markup, they are created and added to the container div.
       * 
       * @param {string} substring
       * 
       * @returns {HTMLElement}
       */
      function jqwrap(substring) {
        if (typeof (substring) === "undefined") {
          substring = "";
        } else
          substring = "-" + substring;
        return $(document.getElementById(id_string + substring));
      }

      var $container = jqwrap();
      // enable below and delete subsequent line when it's time to show Download Path
      var components = ['list', 'controls', 'queue', 'info'];
      if (pg.config.transfer.SendEmailNotification) {
        components.push('email');
      }
      var cachedJqo = {};

      if ($container.length === 1) {
        var classString = "listArea ";
        var gridClass = pg.config.nodeDefaults.gridClass;
        if (typeof (gridClass) !== "undefined" && typeof (gridClass) === "string") {
          $container.addClass(classString + gridClass);
        }
        cachedJqo["container"] = $container;

        for (var i = 0; i < components.length; i++) {
          var name = components[i];
          var $jqo = jqwrap(name);
          if ($jqo.length <= 0) {
            $jqo = $('<div id="' + id_string + "-" + name + '"></div>');
            $jqo.appendTo($container);
          }
          $jqo.addClass('componentContainer');
          $jqo.addClass('ta-' + name);

          cachedJqo[name] = $jqo;
        }
      }
      return cachedJqo;
    },
    downloadButton: function (buttonId) {
      function makeButton(id) {
        var $but = $('#downbutton-' + id);
        var theLabel = pg.config.downloadButtons[id].label;
        if (theLabel.length <= 0) {
          theLabel = lang.downloadButtonLabel;
        }
        if ($but.length <= 0) {
          $but = $('<button id="download-' + id + '" class="button downloadButton">' + theLabel + '</button>');
        }
        return $but;
      }

      function makeContainer(id) {
        var $container = $('<div id="' + id + '" class="buttonContainer"/>');
        return $container;
      }

      function infoContainer(id) {
        var $container = $('<div id="' + id + '-info" class="componentContainer hide"/>');
        return $container;
      }

      var $buttonContainer = $(document.getElementById(buttonId));
      var $button;
      if ($buttonContainer.length <= 0) {
        $button = $(makeButton(buttonId));
        $buttonContainer = makeContainer(buttonId);
        $button.appendTo($buttonContainer);
        $buttonContainer.appendTo('body');
      } else if ($buttonContainer.length >= 1) {
        $button = $(makeButton(buttonId));
        $button.appendTo($buttonContainer);
      }

      if (pg.config.webapp.useBootstrap) {
        $button.addClass('btn btn-success btn-lg');
        $buttonContainer.addClass('col-lg-6');
      }

      $buttonContainer.append(infoContainer(buttonId));
      return $buttonContainer;
    }
  };

  pg.init = {
    trigger: function () {

      var downloads = pg.status.transferAgent.downloads();
      // only trigger the initialization if all remote servers are configured correctly.
      // otherwise, present a warning to the user that should filter up to the web admin.
      if (pg.init.remoteServersProvided()) {

        // Only launch automatically when we have downloaded the application at least once.
        if ( downloads !== null && downloads > 0 ) {
            pg.state.rememberLaunchChoicePending = true;
            pg.localConfig = {};
            pg.status.transferAgent.launchAutomatically();
        }
        // pull configuration info from localStorage/cookies
        pg.init.getCookies();
        pg.config.queryString = pg.utils.parseQuery(window.location.search.substring(1));
        var port = pg.config.localAgent.portDefault;
        var portObj = pg.ta['http.port'];
        if (typeof (portObj) !== "undefined") {
          port = portObj.value;
        }

        // predefine what should happen if initial heartbeat check fails
        var errorHandler = function () {
          var params = {
            port: port,
            attempt: 0,
            success: function () {
              pg.init.afterTaConfirmed(port);
              $( '.modal-manualLaunch' ).modal( 'hide' );
              $( '.modal-manualDownload' ).modal( 'hide' );
              pg.ui.spinnerScreen(false, "heartbeat");
              pg.ui.spinnerScreen(false, "waiting");
              pg.ui.spinnerScreen(false, "initializing");
            },
            error: function () {
              //pg.ui.spinnerScreen(false, "heartbeat");
              if (pg.state.pollHeartbeat) {
                params.attempt++;
                if (typeof (pg.state.launchTime) !== "undefined") {
                  var timeout = pg.config.webapp.launchDetectTimeout;
                  var now = Date.now();
                  if ((now - pg.state.launchTime) <= (timeout * 1000)) {
                    setTimeout(function () {
                      pg.utils.launchAndHeartbeat(params);
                    }, 1000);
                  } else {
                    $('.bootbox.modal').modal('hide');
                    pg.dialog.launchFailed( params );
                  }
                } else {
                  setTimeout(function () {
                    pg.utils.launchAndHeartbeat(params);
                  }, 1000);
                }
              }
            }
          };
          pg.utils.launchAndHeartbeat(params);
        };

        // do an initial heartbeat. On success, initialize UI. On fail, perform
        // the previously defined function errorHandler();
        if ( pg.localConfig.launchAutomatically ) {
            pg.ui.spinnerScreen(true, "heartbeat");
        } else {
            pg.ui.spinnerScreen(true, "initializing");
        }
        pg.utils.getHeartbeat(port, function () {
          pg.init.afterTaConfirmed(port);
        }, errorHandler);
      } else {
        // finish initial conditional -- there are no remote nodes configured
        pg.utils.dialog(lang.errorRemoteNotConfiguredMsg);
      }
    },
    remoteServersProvided: function () {
      var provided = true;
      for (var key in pg.config.remoteNodes) {
        var serverConf = pg.config.remoteNodes[key];
        if (serverConf.pgpMessage.length <= 0) {
          if (serverConf.remoteServer.length <= 0) {
            provided = false;
            break;
          }
        }
      }
      return provided;
    },
    versionCheck: function () {
      var successHandler = function (data) {
        pg.state.currentVersion = JSON.stringify(data);
        // 0 for equal, negative if agent is lesser, positive if agent is greater.
        var compareResults = pg.utils.compareVersion(data, pg.version);
        pg.utils.apiChecks(data);
        //update the service status of TA
        if (pg.available.serviceStatus) {
          pg.utils.checkRunningAsService(pg.utils.runningAsServiceStatusGetSet);
        }
        if (pg.localConfig.declineUpgrade !== pg.state.currentVersion) {
          if (compareResults < 0) {
            pg.dialog.upgrade();
          } else {
            pg.init.fileListings();
          }
        } else {
          // upgrade not required; get the listings.
          pg.init.fileListings();
        }
      };
      pg.getVersionAjax(successHandler);
    },
    afterTaConfirmed: function () {
      pg.state.applicationLaunched = true;

      // Check version
      // **** important: versionCheck is a gatekeeper! It will continue initialization
      // **** once user has downloaded or declined!
      pg.init.versionCheck();

      // Create local listings
      pg.state.localFilesIntialRequest = true;
      pg.init.localFiles();      

      // Find or create standalone download buttons
      pg.init.downloadButtons();

      // store any actions required by the query string
      if (typeof (pg.config.queryString.actions) !== "undefined") {
        pg.config.queryString.actions = pg.config.queryString.actions.split(',');
      }
    },
    getCookies: function () {
      var localCookie = $.cookie('filecatalystLocalConfig');
      if (localCookie) {
        pg.localConfig = $.parseJSON(localCookie);
      } else {
        pg.localConfig = {};
      }

      var taCookie = pg.utils.paramGetCookie();
      if (taCookie) {
        pg.ta = pg.utils.paramToObj(taCookie);
      }
    },
    detectAgent: function () {
      // Mozilla is currently the only browser engine that facilitates (albeit through
      // a hack) detection of an installed protocol handler.
      function testMozilla() {
        var iFrame = $('#hiddenIframe')[0];
        try {
          iFrame.contentWindow.location.href = testUrl;
          pg.state.agentFound = true;
          pg.state.applicationLaunched = true; // the test itself launches the application
          pg.utils.registerInstalled();
        } catch (e) {
          if (e.name === "NS_ERROR_UNKNOWN_PROTOCOL") {
            pg.state.agentFound = false;
          }
        }
      }

      /* Firefox code repurposed from Rajesh Segu: https://gist.github.com/rajeshsegu/3716941#file-browserdetectprotocol-js */
      pg.state.agentFound = false;
      var testUrl = "filecatalyst://localhost";
      var browser = window.browserInfo.browser;
      browser = browser.toLowerCase();

      if (browser === "firefox") {
        $('body').append('<iframe id="hiddenIframe" src="about:blank" style="display:none"></iframe>');
        testMozilla();
      }

      return pg.state.agentFound;
    },
    launchApplication: function () {
      if (!pg.state.applicationLaunched && !pg.state.launchAttempted) {
        //pg.ui.spinnerScreen(true, "heartbeat");
        try {
          var iFrame = $('#hiddenIframe');
          if (iFrame.length <= 0) {
            iFrame = $('<iframe id="hiddenIframe" src="about:blank" style="display:none"></iframe>').appendTo('body');
          }
          iFrame.attr('src', 'about:blank');
          iFrame.attr('src', 'filecatalyst://localhost');
          pg.state.launchAttempted = true;
          pg.state.launchTime = Date.now();
        } catch (e) {
          console.error(e);
          pg.ui.spinnerScreen(false, "connecting");
        }
      } else {
        // should theoretically not get hit, but let's be safe
        // This is getting hit now
        //pg.ui.spinnerScreen(false, "heartbeat");
      }
    },
    detectPort: function (port) {
      if (pg.state.detectEnabled || typeof (pg.state.detectEnabled) === "undefined") {
        if (pg.localConfig.agentInstalled) {
          if (!pg.ta['http.port']) {
            if (typeof (port) !== "number") {
              port = pg.config.localAgent.portDefault;
            }

            var inc = 1;

            // set a detection start time only once per page load
            if (typeof (pg.startTime) === "undefined") {
              pg.startTime = new Date().getTime();
            }

            // get a new elapsed time each time detectPort is run
            var elapsed = new Date().getTime() - pg.startTime;
            var $spinnerText = $('.spinContainer .detectPort');
            if ($spinnerText.length > 0) {
              var $portNumber = $('.portNumber');
              if ($portNumber.length <= 0) {
                if (typeof (port) === "undefined") {
                  port = "";
                }
                $spinnerText.append(
                    '&nbsp;<span class="portNumber">' + port + '</span>&nbsp;&nbsp;<button href="#" id="cancelDetect"'
                    + ' class="btn btn-danger">' + lang.autoDetectCancelButton + '</button>'
                );
              } else {
                $portNumber.html(port);
              }

            } else {
              pg.ui.spinnerScreen(true, "detectPort");
            }

            var url = pg.utils.baseUrl('heartbeat', port);
            $.ajax({
              url: url,
              method: 'GET',
              async: true,
              success: function (data) {
                pg.utils.updateConfig("http.port", port, "INTEGER");
                pg.state.detectRequests = 0;
                pg.state.confirmAttempts = 0;
                pg.ui.spinnerScreen(false, "detectPort");
                pg.init.afterTaConfirmed();
              },
              error: function (xhr, opts, error) {
                if (pg.state.confirmAttempts >= 5) {
                  port += inc;
                  pg.state.detectRequests++;
                } else {
                  pg.state.confirmAttempts++;
                }
                if ((elapsed <= 2 * 60 * 1000) && (pg.state.detectRequests < 5) && port <= 12990) {
                  pg.init.detectPort(port);
                } else {
                  pg.ui.spinnerScreen(false, "detectPort");
                  pg.dialog.detectPort();
                }
              },
              statusCode: {
                0: function () {
                }
              }
            });
          }
        }
      }
    },
    localFiles: function () {
      var _package = {id: "localFiles", connectionKey: "local"};
      if ($('#localFiles').length === 1) {
        _package.$elems = pg.ensure.widgets('localFiles');
        pg.ui.makeArea(_package);
        for (var key in _package.$elems) {
          _package.$elems[key].data("connectionKey", "local");
        }
        pg.list.get(_package);
      }
      pg.utils.storeNode(_package);
    },
    remoteFiles: function () {
      var theNodes = pg.config.remoteNodes;
      for (var key in theNodes) {
        var node = theNodes[key];
        pg.init.delegateConnect(node);
      }
    },
    fileListings: function () {
      if (!pg.state.remoteFilesIntialRequest) {
        pg.init.remoteFiles();
      } else {
        pg.state.remoteFilesIntialRequest = false;
      }
      if (!pg.state.localFilesIntialRequest) {
        pg.init.localFiles();
      } else {
        pg.state.localFilesIntialRequest = false;
      }
    },
    downloadButtons: function () {
      var buttonCfg = pg.config.downloadButtons;

      if (pg.utils.objectLength(buttonCfg) > 0 && typeof (buttonCfg) === "object") {
        for (var key in buttonCfg) {
          if (document.getElementById(key)) {
            pg.ensure.downloadButton(key);
          }
        }
      }
    },
    delegateConnect: function (params) {
      var thisId;
      for (var key in pg.config.remoteNodes) {
        if (JSON.stringify(params) === JSON.stringify(pg.config.remoteNodes[key])) {
          thisId = key;
        }
      }
      var thisConfig = pg.config.remoteNodes[thisId];

      if ((thisConfig.pgpMessage && thisConfig.pgpMessage.length > 0)
        || (thisConfig.username.length > 0 && thisConfig.password.length > 0)
        || (thisConfig.username === "anonymous"))
      {
        // no manual intervention required; go ahead and connect
        pg.init.connect(params, thisId);
      } else {
        // no configuration passed in with JS; check localStorage for stored pgp and connect if found
        if ($.isArray(pg.localConfig.pgp)) {
          thisConfig.pgpMessage = pg.localConfig.pgp;
          pg.init.connect(params, thisId);
        } else {
          pg.state[thisId].manualConfig = true;
          pg.dialog.checkCredentials(params, thisId);
        }
      }
    },
    connect: function (params, thisId) {
      if (pg.state.requestingConnection) {
        return;
      }
      var tempPgpArray = [];
      // if ID isn't supplied, figure it out
      if (typeof (thisId) === "undefined") {
        for (var key in pg.config.remoteNodes) {
          if (JSON.stringify(params) === JSON.stringify(pg.config.remoteNodes[key])) {
            thisId = key;
          }
        }
      }

      var forceGet = false;
      var type = "GET";
      if (typeof (params.pgpMessage) !== "undefined") {
        if (params.pgpMessage.length > 0 && !forceGet) {
          type = "POST";
          if ($.isArray(params.pgpMessage)) {
            // clone the pgpMessage array
            tempPgpArray = params.pgpMessage.slice(0);
            // join up the original pgpMessage
            params.pgpMessage = params.pgpMessage.join('\n');
          }
          params.MungedConnectionRequest = params.pgpMessage;
          params = JSON.stringify(params);
        } else {
          // type is still GET, but we don't need the pgpMessage to be sent
          delete params.pgpMessage;
        }
      }
      pg.ui.spinnerScreen(true, "connecting");
      var url = pg.utils.baseUrl('connect');

      var handleError = function (xhr, opts, error) {
        pg.state.validCreds = false;
        try {
          var checkCommonErrors = pg.utils.commonConnectionErrors(xhr.responseText, false);
          if (!checkCommonErrors) {
            var error = JSON.parse(xhr.responseText);
            if (error && error.reason && error.reason.text) {
              pg.state.lastErrorConnectionMessage = error.reason.text;
            } else {
              pg.state.lastErrorConnectionMessage = "";
            }
          } else {
            pg.state.lastErrorConnectionMessage = checkCommonErrors;
          }
        } catch (e) {
          pg.state.lastErrorConnectionMessage = "";
        }
        pg.ui.spinnerScreen(false, "connecting");
        pg.ui.spinnerScreen(false, "heartbeat");
        if (pg.state[thisId].manualConfig) {
          setTimeout(function () {
            if (typeof (params) === "string") {
              params = $.parseJSON(params);
            }
            // convert pgpMessage back to array of strings
            params.pgpMessage = tempPgpArray;
            pg.dialog.checkCredentials(params, thisId);
          }, 200);
        } else {
          setTimeout(function () {
            pg.dialog.errorConnectingRemote(xhr.responseText);
          }, 200);
        }
      };
      this.handleError = handleError;
      var ajaxOpts = {
        url: url,
        type: type,
        data: params,
        dataType: 'json',
        success: function (data) {
          var siteInformation = data.siteInformation;
          if (siteInformation && siteInformation.SiteSupportedFeatures) {
            if (siteInformation.SiteSupportedFeatures.indexOf("EMAIL") === -1) {
              $("#server1-email, #localFiles-email").hide();
            }
          }
          var $manualDialog = $('.modal-manualLaunch');
          if ($manualDialog.length > 0) {
            $manualDialog.modal('hide');
          }
          var _package = {id: thisId, connectionKey: data.connectionKey};
          if ($('#' + thisId).length === 1) {
            _package.$elems = pg.ensure.widgets(thisId);
            pg.ui.makeArea(_package);
            // store key in file list el$ements
            for (var key in _package.$elems) {
              _package.$elems[key].data("connectionKey", data.connectionKey);
            }
            pg.list.get(_package);
          }
		  pg.utils.verifyStatusOfTransfers(data.connectionKey);
          pg.state.validCreds = true;
          pg.state.lastErrorConnectionMessage = "";
          $.cookie('filecatalystLocalConfig', JSON.stringify(pg.localConfig), {expires: 365});
		  var $heading = $("#" + thisId + "-heading");
		  if($("#removeSavedLogin").length===0){
			$heading.append(
                            '<span id="removeSavedLogin" class="headless" style="display: none;"><a><i'
                            + ' id="iconRemoveCredentials" class="fa fa-key" data-original-title="" title=""></i></a>'
                            + ' </span>'
                        );
			pg.utils.launchPopover();
		  }
		  var credentialStorage = localStorage.getItem("filecatalystLocalConfig");
		  if (credentialStorage !== null) {
			credentialStorage = JSON.parse(credentialStorage);
		  };
		  if (
                      credentialStorage !== null
                      && credentialStorage.pgp !== undefined
                      && credentialStorage.pgp !== null
                  ) {
			$("#removeSavedLogin").show();
		  }
		  
          pg.ui.spinnerScreen(false, "connecting");
          pg.utils.storeNode(_package);
          pg.ui.transferButtonList.make();
          if (typeof (pg.config.queryString.actions) !== "undefined") {
            if ($.inArray('rebuildQueues', pg.config.queryString.actions) > -1) {
              pg.queue.rebuild(_package);
            }
          }
          if($("#connectionTest").length>0){
            $("#connectionTest").data("connectionKey", data.connectionKey);
          }else{
            var btnTestConn = $("<button/>");
            btnTestConn.data("connectionKey", data.connectionKey);
            btnTestConn.html(i18n.t("Test Connection"));
            btnTestConn.addClass("button btn-info btn btn-xs pointer").attr("id", "connectionTest");
            $(".action-transfer").after(btnTestConn);
          }
        },
        error: function (xhr, opts, error) {
          handleError(xhr, opts, error);
        },
        statusCode: {
          500: function () {
            // override default by doing nothing
          },
          0: function () {
            if (!pg.state.manualCredentials)
              pg.dialog.agentAbsent();
          }
        }
      };
      if (type === "POST") {
        ajaxOpts.contentType = 'application/json';
      }
      $.ajax(ajaxOpts).complete(function () {
        var $notification = $('#validating_connection').closest('.bootstrap-growl');
        $notification.fadeOut();
        pg.state.requestingConnection = false;
      });
      pg.state.requestingConnection = true;

      pg.init.redoConnection = function (callBack, errorCall) {
        pg.ui.spinnerScreen(true, "connecting");
        var ajaxOpts = {
          url: url,
          type: type,
          data: params,
          dataType: 'json',
          success: function (data) {
            if (callBack) {
              callBack(data);
            }
            ;
          },
          error: function (xhr, opts, error) {
            if (errorCall) {
              errorCall(xhr, opts, error);
            }
            ;
          },
          complete: function () {
            pg.ui.spinnerPointer(false);
            pg.ui.spinnerScreen(false, "connecting");
          }
        };
        $.ajax(ajaxOpts);
      };
    }
  };

  // pg.utils.dialog() function calls wrapped up as separate discrete functions,
  // for organization rather than execution purposes
  pg.dialog = {
    launchFailed: function ( params ) {
      var uniqueClass = 'modal-launchFailed';
      var bodyMessage = '<p>' + lang.warningLaunchFailed + '</p>';

      if ( pg.utils.detectOS() === "linux" ) {

          bodyMessage =
              '<p>'
              + i18n.t( 'common.warningLaunchFailedLinux' ).
                  replace( '__refresh__', i18n.t("common.launchFailRefreshButton") ) + '</p>';
      } else {

          bodyMessage += '<ul><li>' + i18n.t("common.warningLaunchFailedReason1") + '</li>';
          bodyMessage += '<li>' + i18n.t("common.warningLaunchFailedReason2") + '</li>';
          bodyMessage += '<li>' + i18n.t("common.warningLaunchFailedReason3") + '</li>';
          bodyMessage += '<li>' + i18n.t("common.warningLaunchFailedReason4") + '</li></ul>';
      }
      bodyMessage +=
          '<a class="collapsed" data-toggle="collapse" href="#advancedLaunch" aria-expanded="false"'
          + ' aria-controls="advancedLaunch">';
      bodyMessage += lang.manualLaunchAdvancedLabel + ' <span class="caret"></span></a>';
      bodyMessage += '<div class="panel-collapse collapse" id="advancedLaunch"><div class="well">';
      bodyMessage += '<form class="form-horizontal"><div class="control-group"><fieldset><div class="control-group">';
      bodyMessage +=
          '<label class="control-label" for="portValue">' + i18n.t("common.portNotFoundFieldLabel") + '</label>';
      bodyMessage += '&nbsp;&nbsp;';
      bodyMessage +=
          '<input id="portValue" name="portValue" type="text" class="input-xlarge" value="'
          + pg.config.localAgent.portDefault + '" />';
      bodyMessage += '</div></fieldset></div></form></div></div>';
      var dialogOptions = {
        message: bodyMessage,
        title: lang.agentNotFoundTitle,
        className: uniqueClass,
        buttons: {
          download: {
            label: i18n.t( 'common.warningLaunchFailedReason1Link' ),
            className: "btn-link",
            callback: function () {

                pg.dialog.handlers.download();

                pg.utils.checkAndRelaunchTA( function () {
                    // Launch!
                    pg.utils.launchAndHeartbeat( params );
                } );
            }
          },
          confirm: {
            label: i18n.t("common.applyNewPort") + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].ok,
            className: "btn-success btn-warning",
            callback: function () {
              var port = $('#portValue').val();
              pg.utils.updateConfig("http.port", port, "INTEGER");
              pg.init.afterTaConfirmed();
            }
          },
          refresh: {
            label: lang.launchFailRefreshButton + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].refresh,
            className: "btn-success btn-refresh",
            callback: function () {
              pg.utils.resetLocalStorage();
              location.reload();
              return false;
            }
          }
        }
      };
      pg.ui.spinnerScreen( false, 'heartbeat' );
      pg.utils.resetLocalStorage();
      pg.dialog.hooks.launchFailed = pg.utils.dialog( dialogOptions );
    },
    detectAgent: function () {
      // create an interactive dialog for when TransferAgent is not detected
      var uniqueClass = 'modal-detectAgent';
      var bodyMessage = '<p>' + lang.agentNotFoundMsg + '</p>';
      bodyMessage += '<p>' + lang.agentNotFoundDownloadMsg + '</p>';
      bodyMessage +=
          '<p><a href="' + pg.utils.getLinkForOS("installDoc") + '" target="_blank"><em>' + lang.installGuideLinkText
          + '<em></a></p>';
      var dialogOptions = {
        message: bodyMessage,
        title: lang.agentNotFoundTitle,
        className: uniqueClass,
        buttons: {
          download: {
            label: lang.agentNotFoundButtonDownload + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].download,
            className: "btn-info btn-download",
            callback: function () {
              window.location = pg.utils.getLinkForOS("download");
              return false;
            }
          },
          confirm: {
            label: lang.agentNotFoundButtonConfirm + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].ok,
            className: "btn-success btn-confirm",
            callback: function () {
              pg.state.agentFound = true;
              pg.utils.registerInstalled();
            }
          },
          cancel: {
            label: lang.agentNotFoundButtonCancel + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].remove,
            className: "btn-danger btn-cancel",
            callback: function () {
              pg.utils.dialog(lang.agentNotFoundCancel);
            }
          }
        }
      };
      pg.utils.dialog(dialogOptions);
    },
    detectPort: function (startPort) {
      if (typeof (startPort) !== "number") {
        startPort = pg.config.localAgent.portDefault;
      }
      // create an interactive dialog for when TransferAgent is not detected
      var uniqueClass = 'modal-detectPort';
      var bodyMessage = '<p>' + lang.portNotFoundMsg + '</p>';
      bodyMessage += '<form class="form-horizontal">' +
              '<fieldset>' +
              '<div class="control-group">' +
              '<label class="control-label" for="portValue">' + lang.portNotFoundFieldLabel + '</label>' +
              '&nbsp;&nbsp;' +
              '<input id="portValue" name="portValue" type="text" class="input-xlarge" value="' + startPort + '">' +
              '</div>' +
              '</fieldset>' +
              '</form>';
      var dialogOptions = {
        message: bodyMessage,
        title: lang.portNotFoundTitle,
        className: uniqueClass,
        buttons: {
          retry: {
            label: lang.portNotFoundButtonRetry + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].repeat,
            className: "btn-info btn-retry",
            callback: function () {
              pg.state.confirmAttempts = 0;
              pg.state.detectRequests = 0;
              pg.state.detectEnabled = true;
              pg.init.detectPort();
              return false;
            }
          },
          confirm: {
            label: lang.portNotFoundButtonConfirm + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].ok,
            className: "btn-success btn-confirm",
            callback: function () {
              var port = $('#portValue').val();
              pg.utils.updateConfig("http.port", port, "INTEGER");
              pg.init.afterTaConfirmed();
            }
          },
          cancel: {
            label: lang.portNotFoundButtonCancel + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].remove,
            className: "btn-danger btn-cancel",
            callback: function () {
              pg.utils.dialog(lang.portNotFoundCancel);
            }
          }
        }
      };
      pg.utils.dialog(dialogOptions);
    },
    manualLaunch: function () {
      var isLinux          = pg.utils.detectOS() === "linux";
      var taPort           = pg.ta['http.port'].value || pg.config.localAgent.portDefault;
      var dialogVisible    = $('.modal-manualLaunch').length > 0 ? true : false;
      var browser          = Browser.info().name;
      var uniqueClass      = 'modal-manualLaunch';
      var bodyMessage      = '<p>' + makeLaunchMsg() + '</p>';

      pg.ui.spinnerScreen( false, 'heartbeat' );
      pg.ui.spinnerScreen( false, 'initializing' );

      if ( $( '.modal-manualDownload' ).length > 0 ) {
        // Our download modal is opened, so don't show the first one again.
        return;
      }

      /**
       * Assemble launch message.
       */
      function makeLaunchMsg() {
        var initMsg = lang.manualLaunchMsg;
        // store links that may get used;
        var tryLink = '<a href="#" id="launchTryAgain">' + lang.manualLaunchTryAgain + '</a>';
        var downLink = '<a href="#" id="launchDownload">' + lang.manualLaunchDownload + '</a>';
        var installGuideLink =
            '<a href="' + pg.utils.getLinkForOS("installDoc") + '" id="revealDoc" target="_blank">'
            + lang.installDocDescription + '</a>';

        // select an appropriate manual launch message
        if (isLinux) {
          initMsg = lang.manualLaunchMsgLinux;
        }

        var msg = initMsg.replace('__tryAgain__', tryLink).replace('__download__', downLink);
        msg += '<p>' + lang.installDocIntro + installGuideLink + '</p>';
        return msg;
      }

      if ( pg.status.transferAgent.launches() === null ) {

          pg.status.transferAgent.launches( 0 );
      }

      if (!dialogVisible) {

        // create an interactive dialog for manually configuring the TransferAgent
        if ( browser === 'ie' || browser === 'edge' ) {
            bodyMessage += '<p>' + lang.internetExplorerConfig + '</p>';
        }

        bodyMessage +=
            '<a data-toggle="collapse" href="#advancedLaunch" aria-expanded="false" aria-controls="advancedLaunch">'
            + lang.manualLaunchAdvancedLabel + ' <span class="caret"></span></a>'
            + '<div class="collapse" id="advancedLaunch"><div class="well"><form class="form-horizontal"><fieldset>'
            + '<div class="control-group"><label class="control-label" for="portValue">' + lang.portNotFoundFieldLabel
            + '</label>&nbsp;&nbsp;'
            + '<input id="portValue" name="portValue" type="text" class="input-xlarge" value="' + taPort + '"></div>'
            + '</fieldset></form></div></div>';

        var dialogOptions = {
          message: bodyMessage,
          title: lang.manualLaunchTitle,
          className: uniqueClass,
          closeButton: false,
          buttons: {}
        };

        // We don't show the launch button on Linux.
        if ( !isLinux ) {
            dialogOptions.buttons.launch = {
                label: lang.manualLaunchButton,
                className: 'btn-link btn-confirm',
                callback: pg.dialog.handlers.launch
            };
        }

        dialogOptions.buttons.download = {
            label: lang.agentNotFoundButtonDownload + "&nbsp;&nbsp;" + pg.icon[ pg.icon.currentset ].download,
            className: 'btn-success btn-download',
            callback: pg.dialog.handlers.download
        };

        pg.dialog.hooks.launch = pg.utils.dialog( dialogOptions );
      }
    },
    /**
     * Download modal. This is meant to be shown when the transfer agent is being downloaded. It will show different
     * download screenshots to make sure people know where to find their download from the browser.
     * 
     * @param {method} callback
     */
    manualDownload: function ( callback ) {

        var downloadImage = new Image();
        var downloadImageURL = 'images/';
        var downloadImageURLLarge = 'images/';
        var downloadImageStartSmall =
            '<img id="image-manualDownload" alt="' + i18n.t( 'webDeployment.manualDownloadTitle' ) + '" src="';
        var downloadImageStartLarge = '<img alt="' + i18n.t( 'webDeployment.manualDownloadTitle' ) + '" src="';
        var downloadImageEnd = '" />';

        switch( Browser.info().name ) {
            case 'chrome':
                downloadImageURL += 'download_chrome_small.png';
                downloadImageURLLarge += 'download_chrome_large.png';
                break;
            case 'firefox':
                downloadImageURL += 'download_firefox_small.png';
                downloadImageURLLarge += 'download_firefox_large.png';
                break;
            case 'ie':
                downloadImageURL += 'download_ie_small.png';
                downloadImageURLLarge += 'download_ie_large.png';
                break;
            case 'edge':
                downloadImageURL += 'download_edge_small.png';
                downloadImageURLLarge += 'download_edge_large.png';
                break;
            case 'safari':
                downloadImageURL += 'download_safari_small.png';
                downloadImageURLLarge += 'download_safari_large.png';
                break;
            default:
                downloadImageURL = '';
                downloadImageURLLarge = '';
                downloadImageStartSmall = '';
                downloadImageStartLarge = '';
                downloadImageEnd = '';
        };

        downloadImage.src = downloadImageURL;
        if ( callback !== undefined ) {
            downloadImage.addEventListener( 'load', function () {

                  callback();
            } );
        }

        pg.dialog.hooks.download = pg.utils.dialog( {
            message:
                i18n.t( 'Please use the installer to set up FileCatalyst TransferAgent' ) + '<br /><br />' + lang.installDocIntro
                + '<a href="' + pg.utils.getLinkForOS("installDoc")
                + '" id="revealDoc" target="_blank">'
                + lang.installDocDescription + '</a><br /><br />'
                + downloadImageStartSmall + downloadImageURL + downloadImageEnd,
            title: i18n.t( 'FileCatalyst TransferAgent is Currently Downloading to Your Computer' ),
            className: 'modal-manualDownload',
            closeButton: false,
            buttons: {}
        } );

        $( '#image-manualDownload' ).on( 'click', function () {

            // Open a larger dialog with a larger view of the image.
            pg.dialog.hooks.downloadImage = pg.utils.dialog( {
                message: downloadImageStartLarge + downloadImageURLLarge + downloadImageEnd,
                className: 'modal-manualDownloadImage'
            } );

            $( '.modal-manualDownloadImage img' ).on( 'click', function () {

                pg.dialog.hooks.downloadImage.modal( 'hide' );
            } );
        } );
    },
    manualConfig: function () {
      var taPort = pg.ta['http.port'].value || pg.config.localAgent.portDefault;
      var browser = window.browserInfo.browser;
      browser = browser.toLowerCase();
      // create an interactive dialog for manually configuring the TransferAgent

      // when a valid detection scheme presents itself, may be replaced with a
      // method that returns a boolean. Until then, hardcoded to false
      var installed = false;

      var uniqueClass = 'modal-manualConfig';
      var bodyMessage = '<p>' + lang.manualConfigMsg + '</p><ol>';

      if (!installed) {
          bodyMessage +=
              '<li>' + lang.manualConfigInstructionDownload + ' (<a href="' + pg.utils.getLinkForOS("installDoc")
              + '" target="_blank"><em>' + lang.installGuideLinkText + '</em></a>)</li>';
      }

      bodyMessage +=
          '<li>' + lang.manualConfigInstructionLaunch + '</li><li>' + lang.manualConfigInstructionPort + ' (<a href="'
          + lang.trayIconGuideLocation + '" target="_blank"><em>' + lang.trayIconGuideLinkText + '</em></a>) </li><li>'
          + lang.manualConfigInstructionDone + '</li></ol>';

      if (browser.indexOf('explorer') !== -1) {
          bodyMessage += '<p>' + lang.internetExplorerConfig + '</p>';
      }

      bodyMessage +=
          '<form class="form-horizontal"><fieldset><div class="control-group">'
          + '<label class="checkbox" for="installedCheckbox">'
          + '<input type="checkbox" name="checkboxes" id="installedCheckbox">' + lang.manualConfigCheckLabel
          + '</label></div><div class="control-group"><label class="control-label" for="portValue">'
          + lang.portNotFoundFieldLabel + '</label>&nbsp;&nbsp;'
          + '<input id="portValue" name="portValue" type="text" class="input-xlarge" value="' + taPort + '"></div>'
          + '</fieldset></form>';

      var dialogOptions = {
        message: bodyMessage,
        title: lang.manualConfigTitle,
        className: uniqueClass,
        buttons: {
          download: {
            label: lang.agentNotFoundButtonDownload + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].download,
            className: "btn-info btn-download",
            callback: function () {
              window.location = pg.utils.getLinkForOS("download");
              return false;
            }
          },
          confirm: {
            label: lang.portNotFoundButtonConfirm + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].ok,
            className: "btn-success btn-confirm disabled",
            callback: function () {
              var port = parseInt($('#portValue').val());
              var installed = $('#installedCheckbox').is(':checked');
              pg.localConfig.agentInstalled = installed;
              if (!installed) {
                pg.utils.dialog(lang.manualConfigInstallRequired);
                return false;
              }
              pg.utils.updateConfig("http.port", port, "INTEGER");
              pg.utils.registerInstalled();
              pg.init.afterTaConfirmed();
            }
          },
          cancel: {
            label: lang.portNotFoundButtonCancel + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].remove,
            className: "btn-danger btn-cancel",
            callback: function () {
              pg.utils.dialog(lang.manualConfigCancel);
            }
          }
        }
      };
      pg.utils.dialog(dialogOptions);
      $(document).on('click', '#installedCheckbox', function (e) {
        var $this = $(this);
        e.preventDefault;
        if ($this.is(':checked')) {
          var $dialog = $this.closest('.modal-manualConfig');
          $dialog.find('.btn-confirm').prop('disabled', false).removeClass('disabled');
        }
      });
    },
    errorConnecting: function () {
      if ($('.connectError').length <= 0) {
        var errorMsg = lang.errorConnectingMsg;
        var browser = window.browserInfo.browser;
        browser = browser.toLowerCase();
        if (browser.indexOf('explorer') > -1) {
          errorMsg += lang.internetExplorerConfig;
        }
        pg.utils.dialog({
          message: errorMsg,
          className: "connectError",
          buttons: {
            main: {
              label: lang.errorConnectingButton,
              className: "btn-primary"
            }
          }
        });
      }
    },
    errorConnectingRemote: function (responseText) {
      if ($('.connectError').length <= 0) {
        var errorMsg = '<p>' + lang.errorConnectingRemoteMsg + '</p>';
        var checkCommonErrors = pg.utils.commonConnectionErrors(responseText, true);
        errorMsg = checkCommonErrors ? checkCommonErrors : errorMsg;

        pg.utils.dialog({
          message: errorMsg,
          className: "connectError",
          buttons: {
            main: {
              label: lang.errorConnectingButton,
              className: "btn-primary"
            }
          }
        });
      }
    },
    checkCredentials: function (params, serverId) {
      pg.state.manualCredentials = true;
      var taPort = pg.ta['http.port'].value || pg.config.localAgent.portDefault;
      var thisConfig = pg.config.remoteNodes[serverId];
      var bodyMessage = '<p>' + lang.supplyCredentialsMsg + '</p>';
      if (pg.state.validCreds === false) {
        if (pg.state.lastErrorConnectionMessage !== "") {
          bodyMessage = '<p class="bg-warning">' + pg.state.lastErrorConnectionMessage + '</p>';
        } else {
          bodyMessage = '<p class="bg-warning">' + lang.checkCredentialsMsg + '</p>';
        }
      }

      // in order of preference, displayed name is "pretty name", server ID, or hostname
      var serverName = serverId;
      if (typeof (serverName) === "undefined") {
        serverName = params.remoteServer;
      }
      if (params.name.length > 0) {
        serverName = params.name;
      }

      var uniqueId = serverName.replace(/\./g, '_');
      uniqueId = uniqueId.replace(/ /g, "_");

      var uniqueClass = "confirmCredentials";

      bodyMessage +=
        '<form id="form-' + uniqueId + '" class="form-horizontal">' +
          '<div class="form-group">' +
            '<label class="control-label col-sm-4" for="username-' + uniqueId + '">' + lang.formlabelUsername
            + '</label>' +
            '<div class="col-sm-8">' +
              '<input id="username-' + uniqueId + '" name="username-' + uniqueId
              + '" type="text" class="input-xlarge username" value="' + thisConfig.username + '" />' +
            '</div>' +
          '</div>' +
          '<div class="form-group">' +
            '<label class="control-label col-sm-4" for="password-' + uniqueId + '">' + lang.formlabelPassword
            + '</label>' +
            '<div class="col-sm-8">' +
              '<input id="password-' + uniqueId + '" name="password-' + uniqueId
              + '" type="password" class="input-xlarge password" value="" />' +
            '</div>' +
          '</div>' +
          '<div class="form-group">' +
            '<div class="col-sm-4">' +
              '<input class="form-horizontal-checkbox" type="checkbox" name="checkboxes" id="rememberCredCheckbox-'
              + uniqueId + '" checked="checked">' +
            '</div>' +
            '<label class="checkbox col-sm-8" for="noShowCheckbox">' + lang.rememberCredentialsCheckbox + '</label>' +
          '</div>' +
          '<div class=form-group">' +
            '<a data-toggle="collapse" data-target="#advancedLogin" aria-expanded="false"'
            + ' aria-controls="advancedLogin">' +
            i18n.t( "common.manualLaunchAdvancedLabel" ) +
            ' <span class="caret"></span>' +
            '</a>' +
          '</div>' +
          '<div class="form-group collapse" id="advancedLogin">' +
            '<label class="control-label col-sm-4" for="portValue">' + lang.portNotFoundFieldLabel + '</label>' +
            '<div class="col-sm-8">' +
              '<input id="portValue" name="portValue" type="text" class="input-xlarge" value="' + taPort + '" />' +
            '</div>' +
          '</div>' +
        '</form>';

      var executeLogin = function () {
        thisConfig.username = $('#username-' + uniqueId).val();
        thisConfig.password = $('#password-' + uniqueId).val();
        var save = $('#rememberCredCheckbox-' + uniqueId).is(':checked');
        var pgp = ta.utils.makePgpMessage(thisConfig);

        if (save) {
          pg.localConfig.pgp = pgp.arr;
          $("#removeSavedLogin").show();
        } else {
          sessionStorage.setItem("fileCatalystTASession", pgp.arr);
        }

        thisConfig.username = '';
        thisConfig.password = '';
        thisConfig.pgpMessage = pgp.arr;
        pg.init.connect(thisConfig, serverId);
      };
      pg.executeLogin = executeLogin;
      var dialogOptions = {
        message: bodyMessage,
        title: lang.credentialsDialogTitle + serverName,
        className: uniqueClass,
        closeButton: false,
        buttons: {
          confirm: {
            label: lang.portNotFoundButtonConfirm + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].ok,
            className: "btn-success btn-confirm disabled",
            callback: function () {
              pg.executeLogin();
            }
          },
          cancel: {
            label: lang.portNotFoundButtonCancel + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].remove,
            className: "btn-danger btn-cancel",
            callback: function () {
              pg.utils.dialog(lang.manualConfigCancel);
            }
          }
        }
      };
      pg.utils.dialog(dialogOptions);
      var inputs = '#username-' + uniqueId + ', #password-' + uniqueId;
      function checkComplete($this) {
        var $dialog = $this.closest('.confirmCredentials');
        var user = $('#username-' + uniqueId).val();
        var pass = $('#password-' + uniqueId).val();
        if ((user.length > 0 && pass.length > 0) || user === "anonymous") {
          $dialog.find('.btn-confirm').prop('disabled', false).removeClass('disabled');
          return true;
        } else {
          $dialog.find('.btn-confirm').prop('disabled', true).addClass('disabled');
          return false;
        }
      }
      checkComplete($('#username-' + uniqueId));
      $(document).on('keyup keypress blur change', inputs, function (e) {
        var $this = $(this);
        e.preventDefault;
        checkComplete($this);
      });
    },
    agentAbsent: function () {
      if ($('.agentAbsent').length <= 0) {
        var errorMsg = '<p>' + lang.errorAgentAbsent + '</p>';
        pg.utils.dialog({
          message: errorMsg,
          className: "agentAbsent",
          buttons: {
            main: {
              label: lang.errorConnectingButton,
              className: "btn-primary"
            }
          }
        });
      }
    },
    upgrade: function () {
      // create an interactive dialog for when TransferAgent is not detected
      var uniqueClass = 'modal-upgradeAgent';
      var bodyMessage =
          '<p>' + lang.upgradeJSisNewer + ' <a href="#" onclick="javascript: window.location.reload(true);">'
          + '<i class="fa fa-refresh"></i></a>' + '</p>';
      bodyMessage += '<p><form class="form-horizontal">' +
              '<div class="control-group">' +
              '<label class="checkbox" for="noShowCheckbox">' +
              '<input type="checkbox" name="checkboxes" id="noShowCheckbox">' +
              lang.doNotShowAgainCheckbox +
              '</label>' +
              '</div>' +
              '</form></p>';
      var dialogOptions = {
        message: bodyMessage,
        title: lang.upgradeTitle,
        className: uniqueClass,
        onEscape: function () {
          pg.init.fileListings();
        },
        buttons: {
          download: {
            label: lang.agentNotFoundButtonDownload + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].download,
            className: "btn-info btn-download",
            callback: function (e) {
              e.preventDefault();
              var $thisButton = $(e.target);
              $thisButton.addClass('disabled');
              pg.utils.notifications.show( 'notify.upgrade' );
              window.location = pg.utils.getLinkForOS("download");
              pg.state.pollVersion = true;
              pg.pollVersion();
              return false;
            }
          },
          ignore: {
            label: lang.upgradeButtonIgnore + "&nbsp;&nbsp;" + pg.icon[pg.icon.currentset].remove,
            className: "btn-danger btn-cancel",
            callback: function () {
              pg.state.pollVersion = false;
              pg.init.fileListings();
              if ($('.modal-upgradeAgent').find('#noShowCheckbox').is(':checked')) {
                pg.localConfig.declineUpgrade = pg.state.currentVersion;
                $.cookie('filecatalystLocalConfig', JSON.stringify(pg.localConfig));
              }
            }
          }
        }
      };
      pg.utils.dialog(dialogOptions);
    },
    downloadPathInformation: function () {
      var errorMsg = '<div class="row">';
      var os = window.browserInfo.os.toLowerCase();
      var screenshotSrc = ["images/ta-images/trayiconwindows1.png", "images/ta-images/trayiconwindows2.png"];
      if (os.indexOf("mac") > -1) {
        os = "Mac";
        screenshotSrc = ["images/ta-images/trayiconmac1.png", "images/ta-images/trayiconmac2.png"];
      } else if (os.indexOf("windows") > -1) {
        os = "Windows";
      }
      screenshotSrc[2] = "images/ta-images/configuration-downloadpath.png";

      errorMsg += '<p class="col-lg-12">' + lang.downloadPathInfoIntroduction + '</p>';
      errorMsg += '<div class="col-lg-5"><img src="' + screenshotSrc[0] + '" class="img-responsive pull-right"/></div>';
      errorMsg +=
          '<div class="col-lg-7 spacer-bottom"><img src="' + screenshotSrc[1] + '" class="img-responsive"/></div>';
      errorMsg += '<p class="col-lg-12">' + lang.downloadPathInfoAdditional + '</p>';
      errorMsg +=
          '<div class="col-lg-12"><img src="' + screenshotSrc[2] + '" class="img-responsive img-border"/></div>';
      errorMsg += '</div>';

      pg.utils.dialog({
        message: errorMsg,
        title: lang.downloadPathInfoTitle,
        className: "downloadPathInfo",
        buttons: {
          main: {
            label: lang.downloadPathInfoConfirmButton,
            className: "btn-primary"
          }
        }
      });
    },
    handlers: {
        download: function () {

            // Track download attempts. Used when initializing app to determine whether or not to launch automatically.
            pg.status.transferAgent.downloads( pg.status.transferAgent.downloads() + 1 );

            if ( pg.dialog.hooks.launch !== undefined ) {
                pg.dialog.hooks.launch.modal('hide');
            }

            if ( pg.dialog.hooks.launchFailed !== undefined ) {
                pg.dialog.hooks.launchFailed.modal( 'hide' );
            }

            // Show the download modal.
            pg.dialog.manualDownload( function () {
                // Make sure the download of the application happens after the modal loads (Safari-specific issue):
                window.location = pg.utils.getLinkForOS( 'download' );

            } );

            pg.ui.spinnerScreen( true, 'waiting' );

            return false;
        },
        launch: function () {

            // Track launch attempts.
            pg.status.transferAgent.launches( pg.status.transferAgent.launches() + 1 );

            // We're always remembering automatic launch now.
            pg.state.rememberLaunchChoicePending = true;
            pg.init.launchApplication();

            pg.dialog.hooks.launch.modal('hide');

            pg.ui.spinnerScreen( true, 'heartbeat' );

            // Don't close the modal. It is to be closed by the next successful heartbeat/poll.
            return false;
        }
    },
    hooks: {
        launch: undefined,
        launchFailed: undefined,
        download: undefined,
        downloadImage: undefined
    }
  };

  // objects and functions related to handling file listings
  pg.list = {
    get: function (_package, path) {
      if (typeof (path) === "undefined") {
        path = "";
      }
      var restPath = pg.utils.baseUrl('remote');
      var isInitial = false;
      var sortBy, invert;
      if (_package.connectionKey === "local") {
        restPath = pg.utils.baseUrl('local');
      }
      sortBy =
          (typeof (pg.localConfig.sortColumn) === "undefined")
          ? pg.config.nodeDefaults.sortOn
          : pg.localConfig.sortColumn;
      invert =
          (typeof (pg.localConfig.invertSort) === "undefined")
          ? pg.config.nodeDefaults.invertSort
          : pg.localConfig.invertSort;

      if (path.charAt(0) !== '/') {
        restPath += '/';
      }

      restPath += path + '?sortby=' + sortBy + '&invert=' + invert + '&connectionKey=' + _package.connectionKey;

      // object could exist or not depending on which Ajax calls resolve first
      if (typeof (pg.state[_package.id]) === "undefined") {
        restPath += "&isInitial=true";
        isInitial = true;
      } else if (typeof (pg.state[_package.id].initialized) === "undefined") {
        restPath += "&isInitial=true";
        isInitial = true;
      }
      pg.state[_package.id] = pg.state[_package.id] || {};
      pg.state[_package.id].initialized = true;
      var callBack = function () {
        pg.list.get(_package, path);
      };
      var ajaxObject = {
        url: restPath,
        type: 'GET',
        dataType: 'json',
        success: function (data, status, xhr) {
          if (isInitial && data.fileObjectList.length === 1 && data.fileObjectList[0].isDirectory) {
            pg.list.get(_package, data.fileObjectList[0].path);
            return;
          }
          pg.list.render(data, _package);
          pg.storedNodes[_package.connectionKey].fileSet = data.fileObjectList;
          pg.storedNodes[_package.connectionKey].directory = data.directory;
          pg.localConfig.sortColumn = data.sortby;
          pg.localConfig.invertSort = data.invert;
        },
        error: function (xhr, ajaxOptions, thrownError) {
          console.error(thrownError);

          if (xhr.status === 400) {
            try {
              var xhrObj = JSON.parse(xhr.responseText);
              pg.utils.notifications.show( 'notify.resource_not_accessible_code', xhrObj.code.subcode.value );
            } catch (e) {
              //do nothing;
            }
          }else if(xhr.status === 404){
            pg.utils.notifications.show( 'notify.resource_not_accessible' );
          } else {
            pg.state.applicationLaunched = false;
            pg.state.launchAttempted = false;
            pg.utils.checkAndRelaunchTA(callBack);
          }
        }
      };
      $.ajax(ajaxObject);
    },
    render: function (data, _package) {
      // let's cache a bunch of DOM nodes
      var $elems = _package.$elems;
      var $table = $elems.list.find('table.fileList');
      var $tbody = $table.find('tbody');
      var $thead = $table.find('thead');
      var fileSet = data.fileObjectList;
      var $breadcrumb = $elems.list.find('.breadcrumb');

      // set the breadcrumb navigation
      var dir = data.directory.replace(/\/$/, "");
      var directories = dir.split('/');
      var cumulativePath = "";
      var crumbs = "";
      for (var d = 0; d < directories.length; d++) {
        cumulativePath += encodeURIComponent(directories[d]) + "/";
        if (d === directories.length - 1) {
          crumbs += "<li class='active'>" + directories[d] + "</li>";
        } else {
          crumbs += "<li><a href='" + cumulativePath + "'>" + directories[d] + "</a></li>";
        }
      }
      $breadcrumb.html(crumbs);
      var firstCrumb = "";
      var refreshIcon =
          "<a href='" + cumulativePath + "' style='margin-right:20px'>" + pg.icon[pg.icon.currentset].refresh + "</a>";
      if (data.directory.length > 1) {
        firstCrumb += "<li>" + refreshIcon + "<a href=''>" + lang.rootLabel + "</a></li>";
      } else {
        firstCrumb += "<li class='active'>" + refreshIcon + lang.rootLabel + "</li>";
      }
      $breadcrumb.prepend(firstCrumb);
      var rows = '';
      if (typeof (fileSet) !== "undefined") {
        for (var i = 0; i < fileSet.length; i++) {
          var showDate = true;
          var icon = pg.icon[pg.icon.currentset];
          var itemClass = "";
          var thisFile = fileSet[i];
          if (thisFile.isDirectory) {
            itemClass += 'directory';
            if (thisFile.hasOwnProperty('flaggedName')) {
              var name = thisFile.flaggedName.toLowerCase();
              iconClass = name;
              itemClass += ' specialDirectory';
              showDate = false;
            } else {
              iconClass = 'directory';
            }
            if (thisFile.name === '..') {
              itemClass += ' static';
              iconClass = 'levelup';
              showDate = false;
            }
          } else if (thisFile.isFile) {
            itemClass += 'file';
            iconClass = 'file';
          } else {
            itemClass += 'unknown';
            iconClass = 'default';
          }
          if (itemClass.indexOf('directory') !== -1 || itemClass.indexOf('file') !== -1) {
            rows +=
                '<tr class="pointer ' + itemClass + '" href="' + cumulativePath + encodeURIComponent(thisFile.name)
                + '" data-arrayIndex="' + i + '">';
            if (thisFile.name !== "..") {
              rows += '<td class="icon-checkbox">' + icon.uncheckedbox + '</td>';
            } else {
              rows += '<td></td>';
            }
            rows += '<td class="icon-' + itemClass + '">' + icon[iconClass] + '</td>';
            if (thisFile.name !== '..') {
              rows += '<td class="pointer icon-queue">' + icon["addqueue"] + '</td>';
            } else {
              rows += '<td></td>';
            }
            rows += '<td class="filename" title="' + thisFile.name + '">' + thisFile.name + '</td>';
            rows += '<td class="modified">';
            if (showDate) {
              rows += pg.utils.timeConvert('numerical-hhmm', thisFile.lastModified);
            } else {
              rows += '';
            }
            rows += '</td>';
            if (thisFile.isFile) {
              var converted = pg.utils.sizeConvert(thisFile.size);
              rows +=
                  '<td class="size" data-size=' + thisFile.size + ' title="' + converted.original + '">'
                  + converted.size + '</td>' + '<td class="unit" title="' + converted.original + '">' + converted.unit
                  + '</td>';
            } else {
              rows += '<td></td><td></td>';
            }
            rows += '</tr>';
          }
        }
      } else {
        rows += '<tr><td colspan=7>' + lang.listEmpty + '</td></tr>';
      }

      // update the table body
      $tbody.html(rows);
      if ($elems.list.find('table').height() > parseInt(pg.config.webapp.maxListHeight)) {
        $elems.list.css("height", pg.config.webapp.maxListHeight);
      }

      // update the table header
      var selector = 'th[id*="' + data.sortby + '"]';
      var $thisColumn = $thead.find(selector);
      var chevronClass = "headerSortUp";
      if (data.invert === "true") {
        chevronClass = "headerSortDown";
      }
      $thead.find("th").removeClass(function (index, css) {
        return (css.match(/(^|\s)headerSort\S+/g) || []).join(' ');
      });
      $thisColumn.addClass(chevronClass);
      // deselect the header checkbox
      pg.ui.deselectCell($thead.find('.icon-checkbox'));
    }
  };

  pg.ui = {
    reveal: function ($node, reveal) {
      // wrap plain dom nodes or strings up in jQuery if needed
      $node = pg.utils.jqWrap($node);

      // act on CSS fade only if it made the opacity zero
      $node.on('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function () {
        if (parseInt($node.css('opacity')) === 0) {
          $node.css('display', 'none');
        }
      });

      // reveal refers to showing (true) or hiding (false). Will show by default
      if (typeof (reveal) === "undefined") {
        reveal = true;
      }

      if (reveal) {
        // enter reveal logic
        if ($node.is(':visible') === false || $node.css('opacity') === "0") {
          if (pg.config.webapp.animateRevealedComponents) {
            // reveal with animations
            if (pg.config.webapp.useBootstrap) {
              // handle animated reveals for Bootstrap
              $node.css('display', 'block');
              $node.addClass('fade');
              $node.removeClass('hide');
              setTimeout(function () {
                $node.addClass('in');
              }, 100);
            } else {
              // handled animated reveals for non-Bootstrap
              $node.fadeIn();
            }
          } else {
            // reveal without animations
            $node.show();
          }
        }
      } else {
        // enter hide logic
        if ($node.is(':visible') === true || $node.css('opacity') === "100") {
          if (pg.config.webapp.animateRevealedComponents) {
            // hide with animations
            if (pg.config.webapp.useBootstrap && $node.hasClass('in')) {
              $node.removeClass('in');
            } else {
              $node.fadeOut();
            }
          } else {
            $node.hide();
          }
        }
      }
    },
    deselectCell: function (jqCell) {
      jqCell.removeClass('selected');
      jqCell.html(pg.icon[pg.icon.currentset].uncheckedbox);
    },
    selectCell: function (jqCell) {
      jqCell.addClass('selected');
      jqCell.html(pg.icon[pg.icon.currentset].checkedbox);
    },
    toggleCheck: function (jqCell) {
      // toggle class and icon for checkbox. Refactor to utility class later if reused
      if (jqCell.hasClass('selected')) {
        pg.ui.deselectCell(jqCell);
      } else {
        pg.ui.selectCell(jqCell);
      }
    },
    deselectAll: function ($elem) {
      if (typeof ($elem) !== "undefined") {
        // $elem should typically be a table. Logic will be introduced later as other
        // element types become candidates for all checkboxes being deselected.
        var checkboxes = $elem.find('td.icon-checkbox.selected');
        pg.ui.deselectCell(checkboxes);
      }
    },
    selectClick: function (checkbox, e, node) {
      // any kind of click should toggle checkbox and show controls
      pg.ui.toggleCheck(checkbox);
      pg.ui.reveal(node.$elems.controls);

      // learn more about the current click's row and find out if this table
      // had a previous click
      var thisRow = checkbox.closest('tr');
      var thisIndex = thisRow.data('arrayindex');
      var lastIndex = node.lastClickedSelectIndex;
      var collection = checkbox.closest('table').find('td.icon-checkbox');
      if (typeof (lastIndex) === "undefined") {
        lastIndex = thisIndex;
      }

      // some data items at the top of a list are not actually files, but they do
      // have a data-arrayindex. We need to calculate the offset. The offset is almost
      // always 1, but we can accomodate other non-file data items
      var offset = $(collection[0]).parent().data('arrayindex');

      // in addition to default toggle behaviour, process shift-clicks
      if (e.shiftKey) {
        var start = lastIndex;
        var end = thisIndex;
        if (end < start) {
          end = [start, start = end][0];
        }
        start -= offset;
        end -= offset;
        if (start !== end) {
          var switchMethod = pg.ui.deselectCell;
          if ($(collection[lastIndex - offset]).hasClass('selected')) {
            switchMethod = pg.ui.selectCell;
          }
          for (var i = start; i <= end; i++) {
            switchMethod($(collection[i]));
          }
        }
        document.getSelection().removeAllRanges();
      }

      if (e.metaKey || e.ctrlKey) {
        // the checkbox UI negates the need for CTRL+Select but this conditional
        // serves as a placeholder/reminder for future development
      }
      node.lastClickedSelectIndex = thisIndex;
    },
    makeArea: function (configPackage) {
      // just an alias collecting bite-sized "make" functions
      pg.ui.makeHeader(configPackage);
      pg.ui.makeList(configPackage);
      pg.ui.makeControls(configPackage);
      pg.ui.makeQueue(configPackage);
      // enable below when it's time to show Download Path
      // pg.ui.makePathInfo(configPackage);
      pg.ui.makeInfo(configPackage);
      if (pg.config.transfer.SendEmailNotification) {
        pg.ui.makeEmail(configPackage);
      }
    },
    makeHeader: function (configPackage) {
      var $container = configPackage.$elems.container;
      var $heading = $('#' + configPackage.id + '-heading');

      // only do work on the heading if the application is meant to show them
      if (pg.config.webapp.showFileHeadings) {
        if ($heading.length <= 0) {
          // There is no header; make one and prepend it to the container
          $heading = $('<h2 id="' + configPackage.id + '-heading">').prependTo($container);

        }
        var headingString = $heading.html();
        // only make a new header string if the existing is empty
        if (!$.trim(headingString)) {
          var key = configPackage.connectionKey;
          var theName = "";
          if (key === "local") {
            headingString = lang.headingLocal;
          } else {
            theName = pg.config.remoteNodes[configPackage.id].name;
            // if there is no name provided, use the id as the name
            if (typeof (theName) !== "undefined" && theName.length <= 0) {
              theName = configPackage.id;
            }
            headingString += lang.headingRemote + "&nbsp;" + theName;
          }
          $heading.html(headingString);
          if($("#removeSavedLogin").length===0){
            $heading.append(
                '<span id="removeSavedLogin" class="headless" style="display: none;"><a><i id="iconRemoveCredentials"'
                + ' class="fa fa-key" data-original-title="" title=""></i></a> </span>'
            );
            pg.utils.launchPopover();
          }
		  var credentialStorage = localStorage.getItem("filecatalystLocalConfig");
		  if (credentialStorage !== null) {
		    credentialStorage = JSON.parse(credentialStorage);
		  };
		  if (
                      credentialStorage !== null
                      && credentialStorage.pgp !== undefined
                      && credentialStorage.pgp !== null
                  ) {
		    $("#removeSavedLogin").show();
		  }
        }
      }
    },
    makeList: function (configPackage) {
      var id = configPackage.id;
      var key = configPackage.connectionKey;
      var $elems = configPackage.$elems;
      var $table;
      var header =
          '<tr><th id="' + id + '-select" class="iconColumn icon-checkbox pointer" title="' + lang.tooltips.selectAll
          + '"><i class="fa fa-square-o"></i></th>' +
          '<th id="' + id + '-type" class="sortable pointer iconColumn type"></th>' +
          '<th id="' + id + '-upload" class="iconColumn"></th>' +
          '<th id="' + id + '-name" class="sortable pointer name">' +
          lang.localFilesNameHeader +
          '</th><th id="' + id + '-lastmodified" class="sortable pointer modified">' +
          lang.localFilesModifiedHeader +
          '</th><th id="' + id + '-size" class="sortable pointer size">' +
          lang.localFilesSizeHeader +
          '</th><th class="unit"></th></tr>';
      var table =
          '<table id="' + id + '-fileListTable" class="fileList table table-striped table-condensed table-responsive">'
          + '<thead></thead><tbody></tbody></table>';
      var placeholderRow = "<tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>";
      function makeTable() {
        var config;
        if (key === "local") {
          config = pg.config.localAgent;
        } else {
          config = pg.storedNodes[key];
          if (typeof (config) === "undefined") {
            config = pg.config.nodeDefaults;
          }
        }
        $table = $elems.container.find('table.fileList');
        if ($table.length <= 0) {
          $table = $(table);
          $table.find('thead').html(header);
          $table.find('tbody').html(placeholderRow);
          $elems.list.append('<ol class="breadcrumb"></ol>');
          $elems.list.append($table);
        } else {
          $elems.container.find('thead').html(header);
          $elems.container.find('tbody').html(placeholderRow);
        }
      }
      makeTable();
      return $table;
    },
    makeControls: function (configPackage) {
      // all of the "simple" buttons needed; appear after the transfer controls
      var buttons = {
        addtoqueue: {
          classes: [],
          content: lang.addFilesButton
        },
        removefromqueue: {
          classes: ["btn-warning"],
          content: lang.removeSelectedButton
        },
        clearqueue: {
          classes: ["btn-danger"],
          content: lang.clearQueueButton
        }
      };

      function makeButton(content, classes) {
        var $button = $('<button class="button"></button>');
        $button.html(content);
        for (var i = 0; i < classes.length; i++) {
          $button.addClass(classes[i]);
        }
        if (pg.config.webapp.useBootstrap) {
          $button.addClass('btn btn-xs btn-primary pointer');
        }
        return $button;
      }

      function makeTransferControl() {
        var classes = [];
        var $control;

        // this function gets called if there is only a local and one remote
        // server; buttons can then be simple upload/download buttons
        function regularButton() {
          var transferType;
          if (configPackage.connectionKey === "local")
            transferType = lang.controlAreaUploadButton;
          else {
            transferType = lang.controlAreaDownloadButton;
          }
          classes.push("action-transfer btn-success");
          var $theButton = makeButton(transferType, classes);
          return $theButton;
        }

        // this function gets called if there are more than 2 nodes (we assume it
        // is one local and multiple remote servers. It creates a drop-down menu
        // for selecting transfer destination
        function selectControl() {
          var markup = "";
          markup +=
            '<div class="transferButtonGroup btn-group">' +
            '<button type="button" class="action-transfer btn btn-xs btn-primary" href="#">' +
            lang.controlAreaTransferButton +
            '<span class="queuename"></span></button>' +
            '<button type="button" class="btn btn-xs btn-default dropdown-toggle" data-toggle="dropdown">' +
            '<span class="caret"></span>' +
            '<span class="sr-only">Toggle Dropdown</span>' +
            '</button>' +
            '<ul class="dropdown-menu" role="menu">' +
            '<li class="queuelist-placeholder"><a href="#">Placeholder</a></li>' +
            '</ul>' +
            '</div>';
          return $(markup);
        }

        // logic to determine if simple button or dropdowns are needed. Should be
        // expanded to allow 2 remote servers and NO local listing at some point
        if (pg.utils.objectLength(pg.config.remoteNodes) <= 1) {
          $control = regularButton();
        } else {
          $control = selectControl();
        }
        return $control;
      }

      var $area = configPackage.$elems.controls;
      for (var key in buttons) {
        var $button = $area.find('.action-' + key);
        if ($button.length <= 0) {
          $button = makeButton(buttons[key].content, buttons[key].classes);
          $button.addClass('action-' + key);
          if (pg.config.webapp.useBootstrap) {
            $button.addClass('btn btn-primary');
          }
          $area.append($button);
        }
      }
      var theControls = $('.action-transfer');
      if ($area.find('.action-transfer').length < 1) {
        theControls = makeTransferControl();
        $area.append(theControls);
      }
      return theControls;
    },
    makeQueue: function (configPackage) {
      if (pg.config.webapp.useBootstrap) {
        configPackage.$elems.queue.addClass('well');
      }
      configPackage.queue = {
        fileObjectList: []
      };
      pg.queue.render(configPackage);
    },
    makeInfo: function (configPackage) {

      var $thisArea = configPackage.$elems.info;

      // make one vanilla container to start with and do not attach to DOM
      var $container = $('<div class="statusContainer"/>');

      // if there is a "current status" header, add it in
      if (lang.statusFields.current.heading !== "") {
        $container.append('<h3>' + lang.statusFields.current.heading + '</h3>');
      }

      // if there are singleStatus fields, make a table for them
      if (pg.config.webapp.statusFields.current.length > 0) {
        pg.ui.singleStatusTable().appendTo($container);
      }

      // we don't always need a multi-status table. Make and append it
      // only if the possibility to use it exists
      if (typeof pg.config.transfer.NumberOfClients !== "undefined" && pg.config.transfer.NumberOfClients > 1) {
        pg.ui.multiStatusTable().appendTo($container);
      }

      // if an overall heading exists in the language file, add it to the
      // status container.
      if (lang.statusFields.overall.heading !== "") {
        $container.append('<h3>' + lang.statusFields.overall.heading + '</h3>');
      }

      // if there are overallStatus fields, make a table for them
      if (pg.config.webapp.statusFields.overall.length > 0) {
        pg.ui.overallStatusTable().appendTo($container);
      }

      if ($thisArea.find('table').length <= 0) {
        $container.appendTo($thisArea);
        $(
            '<button class="button btn btn-danger btn-large action-cancelTransfer">' + lang.cancelTransferButton
            + '</button>'
        )
            .appendTo($thisArea);
      }
      return $container;
    },
    singleStatusTable: function () {
      var $table = $('<table class="statusFields singleStatus" />');
      for (var i = 0; i < pg.config.webapp.statusFields.current.length; i++) {
        var rowMarkup =
            '<tr><td class="statusLabel">' + lang.statusFields.current[pg.config.webapp.statusFields.current[i]] + ":"
            + '</td><td class="currentStatus ' + pg.config.webapp.statusFields.current[i] + '"></td></tr>';
        $(rowMarkup).appendTo($table);
      }
      return $table;
    },
    multiStatusTable: function () {
      var $table =
          $(
              '<table class="statusFields multiStatus" style="display:none"><thead><tr></tr></thead><tbody></tbody>'
              + '</table>'
          );
      // if the currentMulti entries don't exist, the user has an old config file. Use original 'current' fields in
      // their stead.
      pg.config.webapp.statusFields.currentMulti =
          pg.config.webapp.statusFields.currentMulti || pg.config.webapp.statusFields.current;
      for (var i = 0; i < pg.config.webapp.statusFields.currentMulti.length; i++) {
        var fieldKey = pg.config.webapp.statusFields.currentMulti[i];
        var headerMarkup = '<th class="statusLabel">' + lang.statusFields.current[fieldKey] + '</th>';
        $table.find('thead tr').append(headerMarkup);
      }
      return $table;
    },
    overallStatusTable: function () {
      var $table = $('<table class="statusFields overallStatus"/>');
      for (var i = 0; i < pg.config.webapp.statusFields.overall.length; i++) {
        var rowMarkup =
            '<tr><td class="statusLabel">' + lang.statusFields.overall[pg.config.webapp.statusFields.overall[i]] + ":"
            + '</td><td class="overallStatus ' + pg.config.webapp.statusFields.overall[i] + '"></td></tr>';
        $(rowMarkup).appendTo($table);
      }
      return $table;
    },
    makeEmail: function (configPackage) {
      var id = configPackage.id;
      var $thisArea = configPackage.$elems.email;
      var accordionState = "";
      if ($thisArea.find('.in').length > 0) {
        accordionState = ' in';
      }
      var checkedString = 'checked';
      if (!pg.config.transfer.SentFilelistInEmail) {
        checkedString = '';
      }
      var bootstrapFormMarkup =
        '<div class="panel-group" id="email-accordion">' +
        '<div class="panel panel-default">' +
        '<div class="panel-heading">' +
        '<h4 class="panel-title">' +
        '<a id="emailAccordionControl" data-toggle="collapse" data-parent="#email-accordion" href="#collapseOne">'
        + pg.icon[pg.icon.currentset].envelope + '&nbsp;&nbsp;' + lang.headingEmail +
        '</a>' +
        '</h4>' +
        '</div>' +
        '<div id="collapseOne" class="panel-collapse ';
        bootstrapFormMarkup += pg.config.webapp.collapseEmailAccordion ? 'collapse out' : '';
        bootstrapFormMarkup += accordionState + '">' +
        '<div class="panel-body">' +
        '<form class="form-horizontal" role="form">' +
        '<div class="form-group" id="formGroup-emailAddress">' +
        '<label for="' + id + '-emailAddress" class="col-sm-2 control-label">' + lang.labelEmail + '</label>' +
        '<div class="col-sm-10">' +
        '<input type="email" class="form-control emailAddress" id="' + id + '-emailAddress" placeholder="'
        + lang.placeholderEmail + '">' +
        '<p class="help-block">' + lang.helpEmail + '</p>' +
        '</div>' +
        '</div>' +
        '<div class="form-group" id="formGroup-emailMessage">' +
        '<label for="' + id + '-emailMessage" class="col-sm-2 control-label">' + lang.labelMessage + '</label>' +
        '<div class="col-sm-10">' +
        '<textarea id="' + id + '-emailMessage" name="email-message" class="form-control emailMessage" rows="5">'
        + '</textarea>' +
        '</div>' +
        '</div>';
      if (!pg.config.transfer.SentFilelistInEmail) {
        bootstrapFormMarkup +=
            '<div class="form-group" id="formGroup-includeList">' +
            '<div class="col-sm-offset-2 col-sm-10">' +
            '<div class="checkbox">' +
            '<label>' +
            '<input id="' + id + '-emailIncludeFiles" class="emailIncludeFiles" type="checkbox"' +
            checkedString +
            '>' + lang.labelIncludeFiles +
            '</label>' +
            '</div>' +
            '</div>' +
            '</div>';
      }

      bootstrapFormMarkup +=
        '</form>' +
        '</div>';

      $thisArea.html(bootstrapFormMarkup);
      return($(bootstrapFormMarkup));
    },
    transferButtonList: {
      make: function () {
        var nodes = pg.storedNodes;

        // if there is only one remote node, upload and download buttons are used
        // instead of a list. Let's set their values.
        if (pg.utils.objectLength(pg.config.remoteNodes) <= 1) {
          var remoteKey;
          for (var theKey in nodes) {
            if (theKey !== "local") {
              remoteKey = theKey;
              break;
            }
          }
          if (typeof (nodes[remoteKey].$elems) !== "undefined") {
            nodes[remoteKey].$elems.controls.find('.action-transfer').attr('data-connectionkey', 'local');
          }
          if (typeof (nodes["local"].$elems) !== "undefined") {
            nodes["local"].$elems.controls.find('.action-transfer').attr('data-connectionkey', remoteKey);
          }
        } else {
          var $buttons = $('.transferButtonGroup');
          var markup = "";
          for (var key in nodes) {
            var tempMarkup = '<li><button data-connectionKey="' +
                    key +
                    '">' +
                    nodes[key].id +
                    '</button></li>';
            markup += tempMarkup;
          }
          $buttons.each(function (i) {
            var $this = $(this);
            var $list = $this.find('ul');
            $list.empty();
            $list.append(markup);
            var myConnectionKey = $this.closest('.listArea').data('connectionKey');
            var myAnchor = $list.find('a[data-connectionkey="' + myConnectionKey + '"]');
            myAnchor.parent().remove();
            var newAnchor = $this.find('li a').first();
            pg.ui.transferButtonList.updateSelected(newAnchor);
          });
        }
      },
      updateSelected: function (anchor) {
        var $anchor = $(anchor);
        var $button = $anchor.closest('ul').siblings('.action-transfer');
        var visibleNode = $anchor.text();
        var visibleKey = $anchor.data('connectionkey');
        $button.find('.queuename').text(" " + visibleNode);
        $button.attr('data-connectionkey', visibleKey);
      }
    },
    finalizeTransfer: function (data, node, type) {
      var _package = pg.utils.createPackage(node.id, node.connectionKey, node.$elems);
      node.activeJobId = null;
      node.activeTarget = null;
      var doAfter;
      // language entry for fields that need more than a "-" during idle
      var customStatusValues = {
          percent:    lang.statusSuccessPercentComplete,
          percentBar: lang.statusSuccessPercentComplete
      };

      function postTask(doAfter) {
        // if files are deleted, refresh the file list
        if (pg.config.transfer.DeleteAfterTransfer) {
          pg.list.get(_package, node.directory);
        }

        // first thing to do is stop the warning that comes from navigating away from the page
        window.onbeforeunload = null;

        pg.utils.processDoAfter(doAfter, data);
      }
      
      if (typeof (data.transferErrors) !== "undefined") {
        errors = true;
      }

      var $status = node.$elems.info;
      var buttonUI = false;

      // detect that this finalize is related to a Download button
      // only Download buttons store a single item in $elems during initialization
      var downbutton = $('.downloadButton#download-' + node.id);
      if (downbutton.length >= 1) {
        buttonUI = true;
      }

      function updateStatus() {
        if (typeof ($status) !== "undefined") {
          var fieldLabels =
              pg.utils.mergeStringArray(pg.config.webapp.statusFields.current, pg.config.webapp.statusFields.overall);
          for (var i = 0; i < fieldLabels.length; i++) {
            $status.find('.' + fieldLabels[i]).html('-');
          }
          for (var key in customStatusValues) {
            $status.find('.' + key).html(customStatusValues[key]);
          }
          node.$elems.infoCurrentMultiTable.find('tbody').empty;
          node.$elems.infoCurrentMultiTable.hide();
          node.$elems.currentTable.hide();
        }
        if (buttonUI) {
          pg.ui.reveal($status, false);
        }
      }

      // no matter how the transfer is finalized, we no longer need the cancel button
      $status.find('.action-cancelTransfer').hide();
      var currentTargetDirectory = data.targetDirectory;
      if (type === "success" || typeof (type) === "undefined" || type === "errors") {
        if (typeof (node.queue) !== "undefined") {
          if (type === "success") {
            pg.queue.clear(node);
          }
          pg.utils.notifications.show( 'notify.file_transfer_complete' );
          doAfter = pg.config.webapp.doAfterSuccess;
        }
        // since the DL is a successful download, show a button for getting to their files
        if (data.transferDirection.toLowerCase() === "download" && !pg.utils.runningAsServiceStatusGetSet()) {
          var callBackCheckDownloadLocation = function(path){
            var $revealButton = node.$elems.info.find('.revealPath');
            if ($revealButton.length <= 0) {
              $revealButton =
                  $(
                      '<button class="revealPath btn btn-primary" data-path="' + path+ '">' + lang.revealPathButton
                      + '</button>'
                  );
              var $downloadButton = $('.downloadButton').filter('#download-' + node.id);
              if ($downloadButton.length >= 1) {
                $revealButton.addClass('btn-lg');
                $downloadButton.replaceWith($revealButton);
              } else {
                node.$elems.info.append($revealButton);
              }
            } else {
              $revealButton.show();
              $revealButton.attr("data-path", path);
			  $revealButton.attr("path", path);
            }
          };
          $.ajax({
            url: "https://localhost.filecatalyst.net:12680/rs/agent/config/download.location",
            contentType: "application/json",
            type:"GET",
            success: function(data){
              if(data && data.dataValue){
                callBackCheckDownloadLocation(data.dataValue);
              }else{
                callBackCheckDownloadLocation(currentTargetDirectory);
              }
            },
            error: function(xhr){
              console.error("fail to check download location...", xhr);
              callBackCheckDownloadLocation(currentTargetDirectory);
            }
          });
        }
      }

      if (type === "cancelled") {
        customStatusValues = {
            percent:    lang.statusCancelledPercentComplete,
            percentBar: lang.statusCancelledPercentComplete
        };
        pg.utils.notifications.show( 'notify.file_transfer_cancelled' );
        doAfter = pg.config.webapp.doAfterCancel;
      }

      if (type === "errors") {
        var errorText =
            lang.fileTransferErrorStatus + ' (<a href="#" class="errorLearnMore">' + lang.generalLearnMoreText
            + '</a>)';
        customStatusValues = {percent: errorText, percentBar: errorText};
        pg.utils.notifications.show( 'notify.file_transfer_error' );
        $(document).on('click', '.errorLearnMore', function (e) {
          e.preventDefault();
          var theErrors = "<ul>";
          for (var i = 0; i < data.transferErrors.length && i < 5; i++) {
            theErrors += "<li>" + data.transferErrors[i].error + "</li>";
          }
          if (data.transferErrors.length.length > 5) {
            var theDiff = data.transferErrors.length - 5;
            theErrors += "<li>" + theDiff + " " + lang.errorsMoreMessage + "</li>";
          }
          theErrors += "</ul>";

          var dialog = '<p>' + lang.errorsListMessage + '</p>' + theErrors;
          dialog += '<p>' + lang.findLogsMessage + '</p>';
          dialog +=
              '<p><a href="' + lang.trayIconGuideLocation + '" target="_blank">' + lang.trayIconGuideLinkText
              + '</a></p>';
          pg.utils.dialog(dialog);
        });
        doAfter = pg.config.webapp.doAfterError;
      }

      updateStatus();

      var $email = node.$elems.email;
      if (typeof ($email) !== "undefined") {
        //$email.find('.panel-body').html('<div class="alert alert-success">' + lang.emailSentMessage + '</div>');
        pg.ui.makeEmail(node);
      }

      pg.ui.transferEnd(node);
      postTask(doAfter);
    },
    spinnerPointer: function (makeVisible) {
      if (typeof (pg.state.pointerSpinnerQueue) === "undefined") {
        pg.state.pointerSpinnerQueue = 0;
      }
      var $body = $('body');
      var $pointer = $('.pointer');
      if (typeof (makeVisible) === "undefined" || makeVisible === "true") {
        makeVisible = true;
      } else if (makeVisible === "false") {
        makeVisible = false;
      }
      if (makeVisible) {
        pg.state.pointerSpinnerQueue += 1;
        $body.addClass('wait');
        $pointer.addClass('wait');
      } else {
        pg.state.pointerSpinnerQueue -= 1;
        if (pg.state.pointerSpinnerQueue <= 0) {
          pg.state.pointerSpinnerQueue = 0;
          $body.removeClass('wait');
          $pointer.removeClass('wait');
        }
      }
    },
    spinnerScreen: function (makeVisible, type) {
      if (typeof (pg.state.screenSpinnerQueue) === "undefined") {
        pg.state.screenSpinnerQueue = [];
      }

      var $spinContainer = $('.spinContainer');
      var $spinBack = $('.spinBack');

      if (typeof (makeVisible) === "undefined") {
        makeVisible = true;
      }
      if (typeof (makeVisible) === "string") {
        type = makeVisible;
        makeVisible = true;
      }

      if (makeVisible) {
        if ($spinContainer.length <= 0) {
          $spinContainer = $('<div class="spinContainer"/>');
          $spinBack = $('<div class="spinBack modal-backdrop in"/>');
          $spinBack.appendTo($spinContainer);
          $spinBack.after('<div class="spinnerWidget"><div class="spinner"></div></div>');
          $spinContainer.appendTo('body');
        }        
        if(pg.state.screenSpinnerQueue.indexOf(type) === -1) {
          pg.state.screenSpinnerQueue.push(type);
          $spinContainer.find('.spinner')
              .after('<div class="spinnerText ' + type + '">' + lang.spinner[type] + '</div>');
        }
      } else {
        $spinContainer.find('.' + type).remove();
        var typePos = pg.state.screenSpinnerQueue.indexOf(type);
        if (~typePos)
          pg.state.screenSpinnerQueue.splice(typePos, 1);
        if (pg.state.screenSpinnerQueue.length <= 0) {
          $spinContainer.remove();
        }
      }
    },
    transferStart: function (node) {
      var $controls = node.$elems.controls;
      if (typeof ($controls) !== 'undefined') {
        $controls.find('.action-transfer').prop('disabled', true);
      }
    },
    transferEnd: function (node) {
      var $controls = node.$elems.controls;
      if (typeof ($controls) !== 'undefined') {
        $controls.find('.action-transfer').prop('disabled', false);
      }
    },
    enableTransferButtons: function () {
      var $transferButtons = $('.action-transfer');
      if ($transferButtons.length > 0) {
        $transferButtons.each(function () {
          $(this).prop('disabled', false);
        });
      }
    }
  };

  pg.getRowInfo = function (jQo) {
    // we are going to naively assume if we called this method, it is from a cell or row
    var thisRow;
    if (jQo.is('tr')) {
      thisRow = jQo;
    } else {
      thisRow = jQo.parent();
    }
    var thisName = thisRow.find("td.filename").text();
    var nodeInfo = pg.utils.getNodeInfo(thisRow);
    var fileListPosition = thisRow.data("arrayindex");
    return {filename: thisName, connectionKey: nodeInfo.key, fileSet: nodeInfo.node.fileSet, filePos: fileListPosition};
  };

  pg.initiateDownload = function (jqObj) {
    var key = jqObj.data("connectionkey");
    var path = jqObj.data("path");
    var fileObj = {
      name: path,
      path: path,
      isDirectory: false,
      isFile: true
    };
    pg.download(key, fileObj);
  };

  pg.queue = {
    localFilter: function (files) {
      var results = {
        pass: true,
        fileList: []
      };

      // we can accept a passed node; othewrise, use fileInfo to pick out the node
      if (typeof (node) === "undefined") {
        var node = pg.storedNodes[files[0].connectionKey];
      }

      // anonymous function to check for duplicate filenames
      function checkDupe(name) {
        var isDupe = false;
        for (var i = 0; i < node.queue.fileObjectList.length; i++) {
          if (name === node.queue.fileObjectList[i].name) {
            isDupe = true;
            break;
          }
        }
        return isDupe;
      }

      // anonymous function to check if file is a directory and then (dis)allow
      function checkDirectoryAllowed(file) {
        var itemAllowed = true;
        // if directories are disallowed, return false and pop a warning
        if (file.isDirectory) {
          if (pg.config.transfer.limitUploadToFiles) {
            itemAllowed = false;
          }
        }
        return itemAllowed;
      }

      // main routine which in turn calls defined filtering functions
      var dupeCount = 0;
      var dupeSingleFileName = '';
      for (var i = 0; i < files.length; i++) {
        var thisPos = files[i].filePos;
        var thisFile = files[i].fileSet[thisPos];
        var thisName = files[i].filename;

        // check for duplicate file being added
        if (checkDupe(thisName)) {
          // confirmed as a duplicate
          dupeSingleFileName = files[i].filename;
          dupeCount++;
        } else {
          // not a dupe, add it to the filtered list
          results.fileList.push(files[i]);
        }
        // check if directories are allowed
        if (results.pass) {
          if (!checkDirectoryAllowed(thisFile)) {
            results.pass = false;
            pg.utils.notifications.show( 'notify.queue_directories_not_allowed', files[i].filename );
            break;
          }
        }
      }
      if (dupeCount > 1) {
          pg.utils.notifications.show( 'notify.queue_duplicate_multiple' );
      } else if (dupeCount > 0) {
		  //FIXING BUG ADDING MESSAGE - BUG 5180
          pg.utils.notifications.show( 'notify.queue_duplicate', dupeSingleFileName );
	  }
      return results;
    },
    taFilterRequired: function (key) {
      var required = false;
      if (key === "local") {
        var taFilters = ["maxfiles", "maxsize", "minsize", "maxtotalsize", "regex"];

        function test(parameter) {
          if (typeof (parameter) === "undefined") {
            return false;
          } else {
            if (parameter === "" || parameter === null) {
              return false;
            }
          }
        }

        for (var i = 0; i < taFilters.length; i++) {
          var parameter = pg.config.transfer[taFilters[i]];
          if (typeof (parameter) !== "undefined") {
            if (parameter !== 0 && parameter !== "" && parameter !== null) {
              required = true;
            }
          }
        }
      }
      return required;
    },
    // TODO: Unsure about the function of this function. How does one run a filter?
    runTaFilter: function (files, successCallback) {
      var key = files[0].connectionKey;
      var config = pg.config.transfer;
      var fileObjectList = [];
      for (var i = 0; i < files.length; i++) {
        fileObjectList.push(files[i].fileSet[files[i].filePos]);
      }
      var requestPayload = {};
      requestPayload.fileQueue = {"fileObjectList": pg.storedNodes[key].queue.fileObjectList};
      requestPayload.filesToAdd = {"fileObjectList": fileObjectList};
      requestPayload.filter = {
        maxfiles: config.maxfiles || -1,
        maxsize: config.maxsize || -1,
        minsize: config.minsize || -1,
        maxtotalsize: config.maxtotalsize || -1,
        regex: config.regex || ""
      };
      var url = pg.utils.baseUrl('local/filter');
      requestPayload = JSON.stringify(requestPayload);
      var callBack = function () {
        pg.queue.runTaFilter(files, successCallback);
      };
      // TODO: Would probably be better as a GET; we are not changing things on the server. However, if we are applying
      // a filter, we are not creating a filter.
      $.ajax({
        data: requestPayload,
        type: 'POST',
        url: url,
        contentType: 'application/json',
        dataType: 'json',
        success: function (data, status, xhr) {
          if (data.passed === true) {
            successCallback();
          } else {
            switch ( data.failureCode ) {
              case 'EXISTING_QUEUE_FAILS_FILTER':
                pg.utils.notifications.show( 'notify.filter_requirements_unmet', data.failureFile.path );
                break;
              case 'MAX_FILES_EXCEEDED':
                pg.utils.notifications
                    .show( 'notify.filter_max_files_exceeded', data.failureFile.path, pg.config.transfer.maxfiles );
                break;
              case 'MAX_FILE_SIZE_EXCEEDED':
                pg.utils.notifications
                    .show( 'notify.filter_max_filesize_exceeded', data.failureFile.path, pg.config.transfer.maxsize );
                break;
              case 'MIN_FILE_SIZE_UNMET':
                pg.utils.notifications
                    .show( 'notify.filter_min_filesize_unmet', data.failureFile.path, pg.config.transfer.minsize );
                break;
              case 'MAX_OVERALL_SIZE_EXCEEDED':
                pg.utils.notifications
                    .show(
                        'notify.filter_max_overall_filesize_exceeded',
                        data.failureFile.path,
                        pg.config.transfer.maxtotalsize
                    );
                break;
              case 'REGEX_FAILED':
                pg.utils.notifications.show( 'notify.filter_regex_unmet', data.failureFile.path );
            };
          }
        },
        error: function () {
          pg.state.applicationLaunched = false;
          pg.state.launchAttempted = false;
          pg.utils.checkAndRelaunchTA(callBack);
        }
      });
    },
    add: function (files, $source) {
      if (files.length > 0) {
        var key = files[0].connectionKey;
        var node = pg.storedNodes[key];
        node.queue = node.queue || {};
        node.queue.connectionKey = key;
        node.queue.fileObjectList = node.queue.fileObjectList || [];
        node.queue.fileList = node.queue.fileList || [];

        for (var i = 0; i < files.length; i++) {
          node.queue.fileObjectList.push(node.fileSet[files[i].filePos]);
          node.queue.fileList.push(node.fileSet[files[i].filePos].path);
        }

        // re-render the queue
        pg.queue.render(node);

        // un-check the source checkboxes
        pg.ui.deselectAll($source);

        // fire a new transfer request if there's an ongoing transfer
        // if (node.activeJobId !== null && typeof (node.activeJobId) !== "undefined") {
        //   var sourceNode = node;
        //   var targetNode = pg.storedNodes[node.activeTarget];
        //   pg.queue.transfer(sourceNode, targetNode);
        // }
      } else {
        pg.ui.deselectAll($source);
      }
    },
    addAction: function (files, $source) {
      var numFiles = files.length;
      if (numFiles > 0) {
        var key = files[0].connectionKey;
        var localFilterResults = pg.queue.localFilter(files);
        files = localFilterResults.fileList;
        if (localFilterResults.pass) {
          if (pg.queue.taFilterRequired(key)) {
            pg.queue.runTaFilter(localFilterResults.fileList, function () {
              pg.queue.add(files, $source);
            });
          } else {
            pg.queue.add(files, $source);
          }
        }
      } else {
        pg.ui.deselectAll($source);
      }
    },
    collectFiles: function (nodeInfo) {
      var files = [];
      var selectedCells = nodeInfo.node.$elems.list.find('td.selected');
      for (var i = 0; i < selectedCells.length; i++) {
        var $cell = $(selectedCells[i]);
        var infoObj = pg.getRowInfo($cell);
        files.push(infoObj);
      }
      pg.ui.spinnerPointer(false);
      return files;
    },
    remove: function (jQo) {
      if (typeof (jQo) === "undefined") {
        jQo = $('.filequeue tr');
      }
      var infoObj = pg.getRowInfo($(jQo[0]));
      var node = pg.storedNodes[infoObj.connectionKey];
      var indexes = [];
      jQo.each(function (i) {
        var thisIndex = $(jQo[i]).closest('tr').data('arrayindex');
        indexes.push(parseInt(thisIndex));
      });
      indexes.sort().reverse();
      for (var k = 0; k < indexes.length; k++) {
        // update the fileList and associated objects
        node.queue.fileObjectList.splice(indexes[k], 1);
        node.queue.fileList.splice(indexes[k], 1);
      }
      pg.queue.render(node);
    },
    storeQueues: function (node) {
      // store the queue for this node in localStorage
      var storedQueues = pg.utils.cookieObjGet('taQueues');
      if (storedQueues === null) {
        storedQueues = {};
      }
      storedQueues[node.id] = node.queue.fileObjectList;
      pg.utils.cookieObjStore('taQueues', storedQueues);
    },
    render: function (node) {
      if (typeof (node.$elems.queue) !== "undefined") {
        // there is not always a rendered queue
        pg.ui.reveal(node.$elems.queue);
      }

      // logic for revealing elements
      var $elems = node.$elems;
      if (typeof ($elems.controls) !== "undefined") {
        if (!($elems.controls.is(':visible'))) {
          pg.ui.reveal($elems.controls);
        }
      }

      if (typeof (node.$elems.queue) !== "undefined") {
        // ensure presence of the table queue
        var emptyTable =
            '<table class="filequeue"><thead><th class="iconColumn"></th><th class="iconColumn"></th><th></th>'
            + '<th class="iconColumn"></th><tbody></tbody></table>';
        var $table = node.$elems.queue.find('table.filequeue');
        if ($table.length <= 0) {
          $table = $(emptyTable);
          $table.prependTo(node.$elems.queue);
        }

        // process the fileListObject and output to the empty queue table
        var $queue = $table.find('tbody');
        $queue.empty(); // clear it out and start from scratch
        var files = node.queue.fileObjectList;
        var numItems = files.length;
        var totalSize = 0;
        if (numItems > 0) {
          for (var i = 0; i < files.length; i++) {
            var thisFile = files[i];
            totalSize += thisFile.size;
            var type = (thisFile.isDirectory) ? "directory" : "file";
            var item = '<tr class="queueItem" href="' + thisFile.path + '"><td class="icon-checkbox pointer">' +
                    pg.icon[pg.icon.currentset].uncheckedbox +
                    '</td><td>' + pg.icon[pg.icon.currentset][type] + '</td><td class="filename">' + thisFile.name +
                    '</td><td class="queue-remove pointer">' + pg.icon[pg.icon.currentset].trash + '</td>';
            $item = $(item);
            $item.attr('data-arrayindex', i);
            $queue.append($item);
          }
        } else {
          $queue.html('<tr><td colspan=4>' + lang.queueEmpty + '</td></tr>');
        }
      }
    },
    clear: function (node) {
      node.queue.fileObjectList = [];
      node.queue.fileList = [];
      pg.queue.render(node);
    },
    transferPut: function (sourceNode, targetNode, prefix) {
      var service = 'transferRev1';
      // if there are any "doAfter" parameters populated, enable navigation warnings
      var doAfters = ["doAfterSuccess", "doAfterError", "doAfterCancel", "doAfterOtherError", "doAfterTransfer"];
      for (var i = 0; i < doAfters.length; i++) {
        var theDoAfter = pg.config.webapp[doAfters[i]];
        if (theDoAfter.length > 0) {
          window.onbeforeunload = pg.utils.confirmOnPageExit;
          break;
        }
      }
      // declare the actual transfer method, which will get called from within the "for" loop
      // multiple times.
      function startTransfer(transferObj) {
        var url = pg.utils.baseUrl(service);

        // the rest of this method is nearly identical to what is found in pg.queue.transfer. There 
        // is an obvious opportunity for proper abstraction and DRY principles. In the meantime,
        // what is different is that the URL is set differently (above), the type is "PUT", and
        // the transferObj passed in has a different signature than before.
        pg.ui.transferStart(sourceNode);
        var ajaxProperties = {
          url: url,
          type: 'PUT',
          data: fileTransferObj,
          dataType: 'json',
          success: function (data) {
            if (data.jobId !== sourceNode.activeJobId) {
              pg.poll.execute(data, sourceNode);
            }
          },
          error: function (xhr, error) {
            var callBack = function () {
              pg.queue.transferPut(sourceNode, targetNode);
            };
            if (xhr.responseText === "") {
              pg.ui.transferEnd(sourceNode);

              pg.utils.processDoAfter(pg.config.webapp.doAfterOtherError);
              pg.state.applicationLaunched = false;
              pg.state.launchAttempted = false;
              pg.utils.checkAndRelaunchTA(callBack);
            } else {
              try {
                var error = JSON.parse(xhr.responseText);
                var errorMessage = error.reason.text;
                if (errorMessage.indexOf("is not a valid connection Key") > -1) {
                  var onError = function () {
                    pg.utils.dialog(lang.lostConnectionFatal);
                  };
                  pg.state.dontThrowConnectionError = true;
                  pg.init.redoConnection(callBack, onError);
                }
              } catch (e) {
                console.error("Not FC XHR Error", e, xhr);
              }
            }
          }
        };
        $.ajax(ajaxProperties);
      }

      // just a wee utility to get only the filename from a given path
      function getFileName(path) {
        return path.split('\\').pop().split('/').pop();
      }

      // turn off polling for version
      pg.state.pollVersion = false;
      var queue = sourceNode.queue;

      if (typeof (targetNode) === "undefined") {
        targetNode = pg.storedNodes['local'];
      }

      // proceed only if there is in fact a queue
      if (typeof (queue) === "undefined" || (typeof (queue.fileList) === "undefined" || queue.fileList.length <= 0)) {
        pg.utils.notifications.show('notify.queue_no_files_waiting');
      } else {
        // for each file in the queue, create a fully armed and operational fileTransferObj,
        // which uses the "source" and "destination" properties instead of the fileList property.
        // Then send it over to the "startTransfer" method to do its thing.
        for (var i = 0; i < queue.fileList.length; i++) {
          
          var sourceFileName = getFileName(queue.fileList[i]);
          
          // ************ WARNING *************** hard-coded "prefix" for proof of concept only!!! 
          // We will need to figure out how to acquire our renamed destination filenames!
          // ************ WARNING ***************
          var destinationFileName = '/' + pg.config.remoteNodes.server1.remoteDirectory + "/" + prefix + '/' + prefix + '-' + sourceFileName;

          // start off the "single file" object just like any other file transfer object -- by grabbing
          // the values found in the configuration file and making a new object with them.
          var fileTransferObj = $.extend({}, pg.config.transfer);

          // extend the new object with more properties: the source/destination keys, and also the
          // sourceFile and destinationFile properties required by the PUT method
          fileTransferObj = $.extend(
            fileTransferObj,
            {
              SourceConnectionKey: sourceNode.connectionKey,
              DestinationConnectionKey: targetNode.connectionKey,
              sourceFile: queue.fileList[i],
              destinationFile: destinationFileName
            }
          );

          // re-use the existing JobId if possible
          // if (sourceNode.activeJobId !== null && typeof (sourceNode.activeJobId) !== "undefined") {
          //   fileTransferObj.jobId = sourceNode.activeJobId;
          // }

          // stringify the transfer object
          fileTransferObj = JSON.stringify(fileTransferObj);

          // fire the transfer object over to the actual transfer method!
          startTransfer(fileTransferObj);
        }
      }
    },
    transfer: function (sourceNode, targetNode) {
      pg.state.pollVersion = false;
      var queue = sourceNode.queue;
      var sendMail = pg.config.transfer.SendEmailNotification;
      // if there is no targetNode passed, assume it is local
      if (typeof (targetNode) === "undefined") {
        targetNode = pg.storedNodes['local'];
      }

      // proceed only if there is in fact a queue
      if (typeof (queue) === "undefined" || (typeof (queue.fileList) === "undefined" || queue.fileList.length <= 0)) {
        pg.utils.notifications.show( 'notify.queue_no_files_waiting' );
      } else {
        if (typeof (sourceNode.$elems) !== "undefined") {
          if (typeof (sourceNode.$elems.email) !== "undefined" && sendMail) {
            // there is an email element, let's grab its values. If anything is
            // null or undefined, the server will simply not send a successful email

            function sendList() {
              var include = false;
              if (pg.config.transfer.SentFilelistInEmail) {
                include = true;
              } else {
                include = $emailForm.find('.emailIncludeFiles').is(':checked');
              }
              return include;
            }

            var $emailForm = sourceNode.$elems.email;
            var formContents = {
              address: pg.utils.getEmails(),
              message: $emailForm.find('.emailMessage').val(),
              includeList: sendList()
            };
          }
        }
        var fileTransferObj = $.extend({}, pg.config.transfer);
        fileTransferObj = $.extend(fileTransferObj, {
          SourceConnectionKey: sourceNode.connectionKey,
          DestinationConnectionKey: targetNode.connectionKey,
          fileList: queue.fileList
        });

        if (sourceNode.activeJobId !== null && typeof (sourceNode.activeJobId) !== "undefined") {
          fileTransferObj.jobId = sourceNode.activeJobId;
        }

        if (typeof (formContents) !== "undefined") {
          fileTransferObj.SentFilelistInEmail = formContents.includeList;
          if (formContents.address !== "") {
            if (fileTransferObj.EmailAddress !== "") {
              fileTransferObj.EmailAddress += ";";
            }
            fileTransferObj.EmailAddress += formContents.address;
          }
          if (formContents.message !== "") {
            var emailBody;
            if (fileTransferObj.EmailBody !== "") {
              emailBody = lang.emailMessageHeaderUser +
                      formContents.message +
                      "\r\n\r\n" +
                      lang.emailMessageHeaderAdmin +
                      fileTransferObj.EmailBody;
            } else {
              emailBody = formContents.message;
            }
            fileTransferObj.EmailBody = emailBody + "\r\n";
          }
        }
        fileTransferObj = JSON.stringify(fileTransferObj);

        // if there are any "doAfter" parameters populated, enable navigation warnings
        var doAfters = ["doAfterSuccess", "doAfterError", "doAfterCancel", "doAfterOtherError", "doAfterTransfer"];
        for (var i = 0; i < doAfters.length; i++) {
          var theDoAfter = pg.config.webapp[doAfters[i]];
          if (theDoAfter.length > 0) {
            window.onbeforeunload = pg.utils.confirmOnPageExit;
            break;
          }
        }

        var url = pg.utils.baseUrl(sourceNode);
        pg.ui.transferStart(sourceNode);
        var ajaxProperties = {
          url: url,
          type: 'POST',
          data: fileTransferObj,
          dataType: 'json',
          success: function (data) {
            if (data.jobId !== sourceNode.activeJobId) {
              pg.poll.execute(data, sourceNode);
            }
          },
          error: function (xhr, error) {
            var callBack = function () {
              pg.queue.transfer(sourceNode, targetNode);
            };
            if (xhr.responseText === "") {
              pg.ui.transferEnd(sourceNode);

              pg.utils.processDoAfter(pg.config.webapp.doAfterOtherError);
              pg.state.applicationLaunched = false;
              pg.state.launchAttempted = false;
              pg.utils.checkAndRelaunchTA(callBack);
            } else {
              try {
                var error = JSON.parse(xhr.responseText);
                var errorMessage = error.reason.text;
                if (errorMessage.indexOf("is not a valid connection Key") > -1) {
                  var onError = function () {
                    pg.utils.dialog(lang.lostConnectionFatal);
                  };
                  pg.state.dontThrowConnectionError = true;
                  pg.init.redoConnection(callBack, onError);
                }
              } catch (e) {
                console.error("Not FC XHR Error", e, xhr);
              }
            }
          }
        };
        $.ajax(ajaxProperties);
      }
    },
    cancel: function (transferid) {
      var url = pg.utils.baseUrl('transfer/cancel');
      var id = {transferID: transferid};
      // TODO: Should be a PUT or PATCH
      $.ajax({
        url: url,
        type: 'GET',
        contentType: 'application/json',
        dataType: 'html',
        data: id,
        success: function (data) {
          // currently no further processing required on successful cancel, since
          // the status object will indicate its success.
        },
        error: function (request, status, error) {
          console.error(error);
        }
      });
    },
    rebuild: function (_package) {
      var id = _package.id;
      var connectionKey = _package.connectionKey;
      var theQueues = $.parseJSON($.cookie('taQueues'));
      pg.storedNodes[connectionKey].queue = {
        connectionKey: connectionKey,
        fileObjectList: theQueues[id]
      };
      pg.queue.render(pg.storedNodes[connectionKey]);
    }
  };

  pg.poll = {
    execute: function (transferData, sourceNode) {
      var id = transferData.jobId;
      pg.storedNodes[sourceNode.connectionKey].activeJobId = id;
      pg.storedNodes[sourceNode.connectionKey].activeTarget = transferData.DestinationConnectionKey;

      function handleError(xhr) {
        pg.ui.transferEnd(sourceNode);
        if(
            typeof pg.config.webapp.doAfterOtherError === "function"
            || (
                typeof pg.config.webapp.doAfterOtherError === "string"
                && pg.config.webapp.doAfterOtherError.length <= 0
            )
        ) {
          pg.utils.dialog(lang.lostConnectionFatal);
        }
        pg.utils.processDoAfter(pg.config.webapp.doAfterOtherError);
        pg.ui.enableTransferButtons();
      }

      if (typeof pg.poll[id] === "undefined") {
        pg.poll[id] = {};
      }

      var sharedAjaxParams = {
        success: function (data, status, jqXHR) {
          // on success, reset the consecutive error checkers
          pg.poll[id].consecutiveErrors = 0;
          pg.poll[id].statusZeroErrors = 0;
          sourceNode.$elems.info.find('.action-cancelTransfer').data('transferid', data.transferID);
          sourceNode.$elems.info.find('.remoteDirectory').html(transferData.remoteDirectory);
          pg.status.render(data, sourceNode);
          if (!data.transferFinished) {
            setTimeout(function () {
              pg.poll.execute(transferData, sourceNode);
            }, 1000);
          }
        },
        error: function (xhr, message) {
          // Status code 0 is treated differently
          if (xhr.status !== 0) {
            pg.poll[id].consecutiveErrors++;
            if (pg.poll[id].consecutiveErrors <= 3) {
              pg.poll.execute(transferData, sourceNode);
            } else {
              handleError(xhr);
            }
          }
        },
        statusCode: {
          0: function () {
            pg.poll[id].statusZeroErrors++;
            if (pg.poll[id].statusZeroErrors <= 3) {
              pg.poll.execute(transferData, sourceNode);
            } else {
              handleError();
            }
          }
        },
        beforeSend: function () {
          // "override" cursor state defaults by not calling them
        },
        complete: function () {
          // "override" cursor state defaults by not calling them
        }
      };

      // The API changed. This conditional allows backwards-compatibility if
      // the newer "status via GET" is available in the TA version
      var extendedAjaxParams = {};
      if (pg.available.statusViaGet) {
        extendedAjaxParams = {
          url: pg.utils.baseUrl('status') + '/' + id,
          method: 'GET',
          async: true
        };
      } else {
        extendedAjaxParams = {
          url: pg.utils.baseUrl('status'),
          method: 'POST',
          data: JSON.stringify({transferID: id}),
          contentType: 'application/json',
          dataType: 'json'
        };
      }

      var combinedAjaxParams = $.extend({}, sharedAjaxParams, extendedAjaxParams);

      // do the actual Ajax call!
      $.ajax(combinedAjaxParams);
    }
  };

  pg.getVersionAjax = function (successHandler, errorHandler) {
    var data = {requester: "TransferAgent Deployment " + pg.version};
    var url = pg.utils.baseUrl('version');

    $.ajax({
      url: url,
      type: 'GET',
      async: true,
      data: data,
      success: function (data) {
        successHandler(data);
      },
      error: function (xhr, opts, error) {
        if (typeof errorHandler === "undefined") {
          console.error(error);
        } else {
          errorHandler(xhr, opts, error);
        }
      },
      statusCode: {
        0: function (xhr) {
          // override default status code 0 behaviour
        }
      }
    });
  };

  pg.pollVersion = function () {
    var successHandler = function (data) {
      var compareResults = pg.utils.compareVersion(data, pg.version);
      if (compareResults < 0) {
        setTimeout(function () {
          pg.pollVersion();
        }, 500);
      } else {
        var $upgradeModal = $('.modal-upgradeAgent');
        $upgradeModal.modal('hide');
        pg.init.fileListings();
      }
    };

    var errorHandler = function (xhr) {
      setTimeout(function () {
        pg.pollVersion();
      }, 500);
    };

    pg.getVersionAjax(successHandler, errorHandler);
  };

  pg.status = {
    // dataSet is the key:value to be populated; $fields are the pre-cached jQuery-wrapped elements
    // to be populated (ie. where the values will go); headers is the list of keys to be used since
    // not the entire dataSet will be populated.
    // Note: The table itself is already in the DOM via makeInfo
    renderVerticalStatus: function (dataSet, $cells, headers) {
      for (var i = 0; i < headers.length; i++) {
        var label = headers[i];
        var currentCell = $cells.filter('.' + label);
        if (typeof (dataSet) !== "undefined") {
          if (typeof (pg.status.format[label]) === "undefined") {
            currentCell.text(dataSet[label]);
          } else {
            currentCell.html(pg.status.format[label](dataSet));
          }
        }
      }
    },
    // the "magic" of the ordering is that headers is an array and will be in
    // the same order as when the table was first created. Should just all work
    // groovy.
    renderMultiStatusTable: function (dataSet, $table, headers) {
      var rows = "";
      for (var h = 0; h < dataSet.length; h++) {
        rows += "<tr>";
        var thisTransfer = dataSet[h];
        for (var i = 0; i < headers.length; i++) {
          var thisHeader = headers[i];
          var content = "";
          if (typeof (pg.status.format[thisHeader]) === "undefined") {
            content = thisTransfer[thisHeader];
          } else {
            content = pg.status.format[thisHeader](thisTransfer);
          }
          rows+= "<td>" + content + "</td>";
        }
        rows += "</tr>";
      }
      $table.find('tbody').html(rows);
    },
    renderCurrentMulti: function (dataSet, sourceNode) {
      // sanity-check that currentMulti exists; if it doesn't then just like makeInfo, use "current"
      pg.config.webapp.statusFields.currentMulti =
          pg.config.webapp.statusFields.currentMulti || pg.config.webapp.statusFields.current;

      var $table = sourceNode.$elems.infoCurrentMultiTable;
      var headers = pg.config.webapp.statusFields.currentMulti;
      pg.status.renderMultiStatusTable(dataSet, $table, headers);

      if(!sourceNode.$elems.infoCurrentMultiTable.is(':visible')) {
        pg.status.swapVisible(sourceNode.$elems.infoCurrentMultiTable, sourceNode.$elems.currentTable);
      }
    },
    renderCurrent: function (dataSet, sourceNode) {
      var $cells = sourceNode.$elems.infoCurrent;
      var headers = pg.config.webapp.statusFields.current;
      pg.status.renderVerticalStatus(dataSet, $cells, headers);

      if(!sourceNode.$elems.currentTable.is(':visible')) {
        pg.status.swapVisible(sourceNode.$elems.currentTable, sourceNode.$elems.infoCurrentMultiTable);
      }
    },
    swapVisible: function($in, $out) {
      if($in instanceof jQuery) {
        $in.show();
      }

      if($out instanceof jQuery) {
        $out.hide();
      }
    },
    renderOverall: function (dataSet, sourceNode) {
      var $cells = sourceNode.$elems.infoOverall;
      var headers = pg.config.webapp.statusFields.overall;
      pg.status.renderVerticalStatus(dataSet, $cells, headers);
    },
    render: function (data, sourceNode) {
      var numTransfers = data.fileTransfers.length;
      if (data.transferErrors.length > 0) {
        pg.erroredFiles.push(data.transferErrors[0]);
      }
      if (data.completedFilesSinceLastUpdate.length > 0) {
        pg.successFiles.push(data.completedFiles[0]);
      }
      // If there is not an existing "info" element cached in the stored sourceNode,
      // make an info area that lives in an overlay dialog
      if (typeof (sourceNode.$elems) === "undefined") {
        var $bbArea;
        if (pg.config.webapp.useBootstrap && typeof (bootbox) !== "undefined") {
          var thisBox = bootbox.alert(' ', function () {
            delete sourceNode.$elems;
          });
          $bbArea = $(thisBox).find('.bootbox-body');
          sourceNode.$elems = {
            info: $bbArea
          };
          pg.ui.makeInfo(sourceNode);
        }
      }

      var $area = sourceNode.$elems.info;

      // cache the cells if they haven't already been cached
      if (typeof (sourceNode.$elems.infoCurrent) === "undefined") {
        sourceNode.$elems.currentTable = $area.find('table.singleStatus');
        sourceNode.$elems.infoCurrentMultiTable = $area.find('table.multiStatus');
        sourceNode.$elems.infoOverall = $area.find('table.statusFields').find('td.overallStatus');
        sourceNode.$elems.infoCurrent = $area.find('table.statusFields').find('td.currentStatus');
      }

      if (typeof ($area) === "object") {
        if (numTransfers > 1) {
          pg.status.renderCurrentMulti(data.fileTransfers, sourceNode);
        } else {
          pg.status.renderCurrent(data.fileTransfers[0], sourceNode);
        }
        pg.status.renderOverall(data, sourceNode);

      }

      $area.find('.action-cancelTransfer').show();
      if (!$area.is(':visible')) {
        pg.ui.reveal($area);
      }
      if (data.transferFinished) {
        if (data.transferComplete || data.transferCancelled) {
          var finalizeType = "success";
          if (data.transferCancelled) {
            finalizeType = "cancelled";
          } else {
              if (typeof (data.transferErrors) !== "undefined") {
                if (data.transferErrors.length > 0) {
                  finalizeType = "errors";
                }
              }
          }
          pg.ui.finalizeTransfer(data, sourceNode, finalizeType);
        }
      }
    },
    format: {
      isOverall: function (set) {
        if (typeof (set.transferID) !== "undefined") {
          return true;
        }
        return false;
      },
      filesSoFar: function (set) {
        var value = set.filesSoFar;
        var doCombine = true;
        var haystack = pg.config.webapp.statusFields.current;
        // when totalFiles is not rendered separately, filesSoFar is rendered as
        // x/y; for example, 1/20 if one file has been transferred out of twenty total
        if (pg.status.format.isOverall(set)) {
          haystack = pg.config.webapp.statusFields.overall;
        }
        if ($.inArray("totalFiles", haystack) > -1) {
          doCombine = false;
        }
        if (doCombine) {
          value = "" + set.filesSoFar + " / " + set.totalFiles;
        }
        return value;
      },
      percentBar: function (set) {
        // classes is a 2-member array of strings. The first are classes applied
        // to the progress container; the second are classes applied to the progress bar
        var markup = '<div class="progress progress-striped" style="width:150px;">';
        markup += '<div class="progress-bar" style="width:' + set.percent + '%">';
        markup += '</div></div>';
        return markup;
      },
      statusMessage: function (set) {
        var value = set.statusMessage;
        return value;
      },
      rateAverage: function (set) {
        return Math.round(set.rateAverage);
      },
      overallTimeRemaining: function (set) {
        return pg.utils.durationConvert(set.overallTimeRemaining);
      },
      timeRemaining: function (set) {
        return pg.utils.durationConvert(set.timeRemaining);
      },
      currentFileTimeRemaining: function (set) {
        return pg.utils.durationConvert(set.timeRemaining);
      },
      packetLossPercent: function (set) {
        return Math.round(set.packetLossPercent) / 100;
      },
      transferTime: function (set) {
        return pg.utils.durationConvert(set.transferTime);
      },
      transferMode: function (set) {
       var usesSSL = typeof set.useSSL === "undefined" ? "unknown" : set.useSSL;

        var mode = set.transferMode;
        mode = "" + mode;
        switch (mode) {
          case "1":
            mode = "FTP";
            break;
          case "2":
            mode = "AUTO";
            break;
          case "3":
            mode = "HTTP";
            break;
          case "4":
            mode = "UDP";
            break;
          default:
            mode = "unknown";
        }

        var lockIcon = "";
        var lockIconClass = "unlock-alt";
        if (typeof usesSSL === "boolean") {
          lockIconClass = usesSSL ? "lock" : "unlock";
        }
        lockIcon = "<i class='fa fa-" + lockIconClass + "'></i>";
        if (usesSSL === "unknown") {
          lockIcon += "<i class='fa fa-question-circle'></i>";
        }
        return mode + "&nbsp;" + lockIcon;
      }
    },
    /**
     * Manage the persistence of the last actions performed relating to downloading TA and/or starting TA on the client
     * machine.
     */
    transferAgent: {

        properties: {
            // Holds the amount of launches the user has initiated
            launches: 'manualTALaunches',
            // Holds the amount of downloads the user has initiated
            downloads: 'manualTADownloads'
        },
        /**
         * Get or set the amount of launches the user has initiated.
         *
         * @param  attempts {number} The new amount of launches that were initiated.
         * @return          {number} The current amount of launches that were initiated. If attempts parameter is
         *                           provided, it will return that number.
         */
        launches: function ( attempts ) {

            return pg.status.transferAgent.persist( pg.status.transferAgent.properties.launches, attempts );
        },
        /**
         * Get or set the amount of downloads the user has initiated.
         *
         * @param  attempts {number} The new amount of downloads that were initiated.
         * @return          {number} The current amount of downloads that were initiated. If attempts parameter is
         *                           provided, it will return that number.
         */
        downloads: function ( attempts ) {

            return pg.status.transferAgent.persist( pg.status.transferAgent.properties.downloads, attempts );
        },
        /**
         * Get or set a number persistence property.
         *
         * @param  property {string} The name of the persistence property to modify/retrieve.
         * @param  value    {number} The new value of the persistence property.
         * @return          {number} The current value of the persistence property. If the value parameter is provided,
         *                           it will return that number.
         */
        persist: function ( property, value ) {

            var currentValue;

            if ( value !== undefined ) {
                window.localStorage.setItem( property, value );
            }

            currentValue = window.localStorage.getItem( property );

            if ( currentValue !== null ) {
                currentValue = parseInt( currentValue );
            }

            return currentValue;
        },
        /**
         * Forget amount of launches and downloads for TA by the user.
         */
        reset: function () {

            window.localStorage.removeItem( pg.status.transferAgent.properties.launches );
            window.localStorage.removeItem( pg.status.transferAgent.properties.downloads );
        },
        /**
         * Set application to launch automatically.
         */
        launchAutomatically: function () {
            if ( typeof ( pg.state.rememberLaunchChoicePending !== "undefined" ) ) {
                if ( pg.state.rememberLaunchChoicePending === true ) {
                    pg.localConfig.launchAutomatically = true;
                    $.cookie( 'filecatalystLocalConfig', JSON.stringify( pg.localConfig ), { expires: 365 } );
                    delete pg.state.rememberLaunchChoicePending;
                }
            }
        }
    }
  };

  /* todo: refactor this to use browserInfo; $.browser() is deprecated */
  pg.xDomainAjax = function (url, settings) {
    if ($.browser.msie && parseInt($.browser.version, 10) >= 8 && XDomainRequest) {
      // use ms xdr
      var xdr = new XDomainRequest();
      xdr.open(settings.type, url + '?' + $.param(settings.data));
      xdr.onprogress = function () {
      };
      xdr.onload = function () {
        settings.success(xdr.responseText);
      };
      xdr.onerror = settings.error;
      xdr.send();
    } else {
      // use jQuery ajax
      $.ajax(url, settings);
    }
  };

  var ta = ta || {};
  ta.utils = ta.utils || {};

  /**
   * NOTE: ta.utils.makePgpMessage is only available if it is included from its separate file
   * (filecatalyst_transferagent_pgpModule.js). Otherwise attempts to access it will result in a warning alert.
   *
   * ta.utils.makePgpMessage can be used to pre-process calls to ta.api.transfer by ensuring that the "local" key is set
   * to either source or destination depending on callType of "upload" or "download" more accurately, "upload" vs. any
   * other string.
   *
   * @memberof ta
   *
   * @param {Object}  options                  An object containing authentication and connection parameters. Note that
   *                                           an object matching the cleartext version of the parameters may optionally
   *                                           be passed in and it will be mapped to the final parameters. The optional
   *                                           notations are: remoteServer, username, password, usesSSL,
   *                                           remoteDirectory, createDirectoryOnConnect, and lockInitialDirectory.
   * @param {string}  options.Server           IP or hostname of an active FileCatalyst Server, third party FTP servers
   *                                           are not supported.
   * @param {number}  options.RemotePort       The FileCatalyst Server command port. 21 is default for non-secure port
   * @param {string}  options.Username         Username for an account on the FileCatalyst Direct Server
   * @param {string}  options.Password         Password for the account on the FileCatalyst Direct Server
   * @param {string}  options.RemoteDirectory  After connection, the initial file list will come from this specified
   *                                           subdirectory of the user account.
   * @param {boolean} options.UseSSL           When true, attempt to connect using the secure socket layer. Note: you
   *                                           will typically need to supply a secure port (FTPS default is 990) in the
   *                                           RemotePort parameter.
   * @param {boolean} options.CreateDirectoryOnConnect
   *                                           If a RemoteDirectory is specified but does not exist, it will be created
   *                                           upon connection.
   * @param {boolean} options.LockInitialDirectory
   *                                           When true AND a RemoteDirectory is supplied/created, prevent the user
   *                                           from retrieving listings from higher in the directory tree of their user 
   *                                           account.
   */
  ta.utils.makePgpMessage = function (options) {

    // set some sensible defaults
    var defaults = {
      Server: "",
      RemotePort: 21,
      Username: "",
      Password: "",
      RemoteDirectory: "",
      UseSSL: false,
      CreateDirectoryOnConnect: false,
      LockInitialDirectory: false,
      ServletURL: "",
      ConnectionMode: -1
    };

    options = mapOptions(options);
    var params = $.extend({}, defaults, options);

    var publicKey = "-----BEGIN PGP PUBLIC KEY BLOCK-----\r\n" +
            "Version: OpenPGP.js v0.6.0\r\n" +
            "Comment: http://openpgpjs.org\r\n" +
            "\r\n" +
            "xo0EU5oCXQED/3ShDXne98bHtFYD8Igo2UYSV5qhlhSdgtkkmrkeIcPYK604\r\n" +
            "fZAhylwSiAQxNI/AGN7YUJiTVsfpLqCHR8keyoFgeVfmB8dar9ZDStY2Gvks\r\n" +
            "NbCOJ9La/ce7RWp/avoOtKawdn4Zp1jIUYFMIGuKenNDSkNACFgmb3CvdM4Z\r\n" +
            "aCXPABEBAAHNDEZpbGVDYXRhbHlzdMKyBBABCAAmBQJTmgJeBgsJCAcDAgkQ\r\n" +
            "2Hegx0nnjXUEFQgCCgMWAgECGwMCHgEAAJtHA/0UPos0EwzK6ZVnpYTWzm9w\r\n" +
            "ndNQCEn0KWDpjFuaf1pBTkvw+CQpO3C76XnQX3Uv6FTcl0SWe5/w+UoUTgxH\r\n" +
            "ZcZ9arI34hDqEleuo0ZRUj476UM64peKkNhseZvoU9Tl6iOQ82LsLPpbTi2M\r\n" +
            "koDVXRkFBRZ2zueiltZ3HOMH/14bbM6NBFOaAl4BBADPBgX4QnlKj4aarCP4\r\n" +
            "FR8IpxahODHlj18fzdy+9qpK8Di+Mw7J5b8kdxO3FbxFjnTZAoEaOoNRh41t\r\n" +
            "LRlR84NibRIbBeoBGQ2ESymOxeLLoSJutr+YRKZl06ZjeRNOT0XqaCCwX+QZ\r\n" +
            "QwoWaYcLkkpR5VORq6VqcWEzgu60SgLYKQARAQABwp8EGAEIABMFAlOaAl4J\r\n" +
            "ENh3oMdJ5411AhsMAAAceQP9Ee/2+Y6BmnosNKHMfcXSGmIhyjZQYhFRXXjf\r\n" +
            "gkSiSgQFVNetr49wB+Iktzm/MLXJwpK6E2MtLx4VcoPh6BNX/L/8D4NDJGs6\r\n" +
            "thPJLTC6GM9rb45+m8lQfvvyB4wUi4yKj5kKS9o0w7mi1MA5nlMPh6hoh/U3\r\n" +
            "EC2UhQMhk5BBP7c=\r\n" +
            "=wrBc\r\n" +
            "-----END PGP PUBLIC KEY BLOCK-----\r\n";

    function encrypt() {
      var keyObj = {};
      var keys = openpgp.key.readArmored(publicKey);
      // you can only encrypt a string!
      var message = JSON.stringify(params);
      var theKey = openpgp.encryptMessage(keys.keys, message);
      keyObj.key = theKey;

      (function () {
        var keyArr = theKey.split(/\r\n|\r|\n/g);
        keyObj.arr = keyArr;
        var output = "[";
        for (var i = 0; i < keyArr.length - 1; i++) {
          output += '"' + keyArr[i];
          if (i === keyArr.length - 2) {
            output += '"]';
          } else {
            output += '",\r\n';
          }
        }
        keyObj.strArr = output;
      }());
      return keyObj;
    }

    // the parameters needed for pgp message have the case set differently. Let's map a standard configured node to the
    // expected casing of pgpMessage.
    function mapOptions(obj) {
      var returnedObj = {};
      var plnParams = [
          "remoteServer", "remotePort", "username", "password", "remoteDirectory", "usesSSL",
          "createDirectoryOnConnect", "lockInitialDirectory", "servletURL", "connectionMode"
      ];
      var pgpParams = [
          "Server", "RemotePort", "Username", "Password", "RemoteDirectory", "UseSSL", "CreateDirectoryOnConnect",
          "LockInitialDirectory", "ServletURL", "ConnectionMode"
      ];
      for (var i = 0; i < plnParams.length; i++) {
        if (obj.hasOwnProperty(plnParams[i])) {
          returnedObj[pgpParams[i]] = obj[plnParams[i]];
        } else {
          returnedObj[pgpParams[i]] = obj[pgpParams[i]];
        }
      }
      return returnedObj;
    }

    return encrypt();
  };
  //https://localhost.filecatalyst.net:12680/rs/agent/connect/connectivityTest/{ConnectionKey}
  /**
  * pg.api.testConnectionKey test a site to check the availability of TCP Channel (single and multi stream), UDP and
  * HTTP.
  *
  * @memberof pg.utils
  * @method testConnectionKey
  *
  * @param {string} ConnectionKey     connection key returned after a connection
  * @param {method} [successCallback] A method that accepts and handle the data returned by the request. For this
  *                                   method, the data is an object reporting the results of send the files to server.
  * @param {method} [errorCallback]   A method that accepts and handles the xhr object from an error state request.
  */
  pg.utils.testConnectionKey = function(ConnectionKey, successCallback, errorCallback){
      var path = 'agent/connect/connectivityTest';
      var url = pg.utils.baseUrl(path) + "/" + ConnectionKey;

      $.ajax({
        cache: false,
        url: url,
        type: 'GET',
        success: function(data) {
          if(successCallback)successCallback(data);
        },
        error: function(xhr) {
          if(errorCallback)errorCallback(xhr);
        }
      });
  },

  pg.utils.removeSavedLogin = function () {
    localStorage.removeItem("filecatalystLocalConfig");
    pg.utils.closePopover('iconRemoveCredentials');
    $("#removeSavedLogin").hide();
  };
  pg.utils.closePopover = function (element) {
    if (element instanceof jQuery) {
      element.popover('hide');
      return true;
    } else if (!(element instanceof jQuery) && typeof (element) === "string") {
      $("#" + element).popover('hide');
      return true;
    } else {
      return false;
    }
  };

  // wrap all the UI binding into one SEAF simply for organizational purposes
  (function () {
    $(document).on('click', '.icon-queue, tr.file td:not(.icon-queue):not(.icon-checkbox)', function (e) {
      e.preventDefault();
      var file = pg.getRowInfo($(this));
      var files = [file];
      pg.queue.addAction(files);
    });

    $(document).on('click', '#connectionTest', function (e) {
      var connectionKey = $(this).data("connectionKey");
      /*
      * Get the response of data and translate as a visual element which represents the current state of the
      * connections. It relies on bootbox.
      *
      * @param data {Object} XHR response to be used to generate the mentioned visual element.
      */
      var analyzeResponse = function(data){
      	if(!data){
            console.error("Mal-formatted data", data);
            return data;
      	};
      	var results = data.testResults;
      	if(results && !($.isEmptyObject(results))){
            var dv = "<table class='table table-striped table-condensed'>";
            dv += "<thead><tr>";
            dv += "<th class='col-xs-6 '> Item Tested</th>";
            dv += "<th class='col-xs-1 '> Success</th>";
            dv += "<th class='col-xs-5 '> Details </th>";
            dv += "</tr></thead><tbody>";
            for(var prop in results){
                var value = "";
                var extraMsg = "";
                var label = results[prop].label;
                switch(results[prop].testResult){
                    case 1:
                        value = '<i class="fa fa-check-circle alert-success" aria-hidden="true"></i>';
                        break;
                    case 2:
                        value = '<i class="fa fa-times alert-danger" aria-hidden="true"></i>';
                        extraMsg = results[prop].errorMessage;
                        break;
                    default:
                        value = '<i class="fa fa-pause" aria-hidden="true"></i>';
                        extraMsg = "Not executed";
                }
                dv += "<tr>";
                dv += "<td class='col-xs-6 '>"+ label +"</td>";
                dv += "<td class='col-xs-1 '>"+ value +"</td>";
                dv += "<td class='col-xs-5 '>"+ extraMsg +"</td>";
                dv += "</tr>";
            }
            dv += "</tbody></table>";
            bootbox.dialog({
                size:"large",
                message: dv,
                title: "Connection Test Results",
                buttons:{
                    ok: {
                        label:     "Close",
                        className: "btn-primary",
                        callback:  function() {}
                    }
                }
            });
      	}
      	return data;
      };
      var error = function(xhr){
        try {
          var checkCommonErrors = pg.utils.commonConnectionErrors(xhr.responseText, false);
          if (!checkCommonErrors) {
            var error = JSON.parse(xhr.responseText);
            if (error && error.reason && error.reason.text) {
              pg.state.lastErrorConnectionMessage = error.reason.text;
            } else {
              pg.state.lastErrorConnectionMessage = "";
            }
          } else {
            pg.state.lastErrorConnectionMessage = checkCommonErrors;
          }
        } catch (e) {
          pg.state.lastErrorConnectionMessage = "";
        }
      };
      pg.utils.testConnectionKey(connectionKey, analyzeResponse, error);
    });

    $(document).on('click', '.button.action-addtoqueue', function (e) {
      e.preventDefault();
      pg.ui.toggleCheck($("th.icon-checkbox"));
      var nodeInfo = pg.utils.getNodeInfo($(this));
      var files = pg.queue.collectFiles(nodeInfo);
      var $listSource = nodeInfo.node.$elems.list;
      pg.queue.addAction(files, $listSource);
    });

    $(document).on('click', 'th.icon-checkbox', function (e) {
      e.preventDefault();
      var jqCell = $(this);
      pg.ui.toggleCheck(jqCell);
      var $tableCells = jqCell.closest('table').find('td.icon-checkbox');
      if (jqCell.hasClass('selected')) {
        $tableCells.each(function () {
          pg.ui.selectCell($(this));
        });
      } else {
        $tableCells.each(function () {
          pg.ui.deselectCell($(this));
        });
      }
    });

    $(document).on('click', '#cancelDetect', function (e) {
      e.preventDefault();
      pg.state.detectEnabled = false;
      pg.ui.spinnerScreen(false, "detectPort");
      pg.dialog.detectPort();
    });

    $(document).on('change', '#formGroup-emailAddress input[type="email"]', function (e) {
      var input = $(this);
      var emails = input.val().split(";");

      for (i = 0; emails.length > i; i++) {
        var email = emails[i].trim();
        var d = new Date();
        var n = d.getTime();
        if (email.length > 0) {
          var validationClass = pg.utils.validateEmail(email) ? "valid" : "invalid";
          var title = pg.utils.validateEmail(email) ? '' : 'title="' + i18n.t("common.invalidEmail") + '"';
          var tag =
              '<a ' + title + ' href="#" class="button btn btn-xs btn-default ' + validationClass
              + '"><span class="pure-email ' + validationClass + '" id="' + n + '">';
          tag += email;
          tag +=
              '</span> &nbsp;<span class="icon-invalid"><i class="fa fa-times-circle-o" aria-hidden="true"></i>'
              + '</span><span class="icon-valid"><i class="fa fa-check-circle-o" aria-hidden="true"></i></span>&nbsp;';
          tag += '<span class="discard-email"><i class="fa fa-trash-o" aria-hidden="true"></i></span></a>';
          input.closest("div").prepend(tag);
        }
      }
      input.val("");

    });
    $(document).on('click', '.discard-email', function (e) {
      $(this).closest("a").remove();
    });
    $(document).on('click', '.action-transfer', function (e) {
      e.preventDefault();
      var sourceNode = pg.storedNodes[$(this).parent().data('connectionKey')];
      var targetKey = $(this).data('connectionkey');
      var targetNode = pg.storedNodes[targetKey];
      pg.queue.transferPut(sourceNode, targetNode);
    });

    $(document).on('click', '.button.action-clearqueue', function (e) {
      e.preventDefault();
      var nodeInfo = pg.utils.getNodeInfo($(this));
      if (typeof (nodeInfo.node.queue) !== "undefined") {
        pg.queue.clear(nodeInfo.node);
      } else {
        pg.utils.notifications.show( 'notify.queue_no_files_removed' );
      }
    });

    $(document).on('click', '.button.action-cancelTransfer', function (e) {
      e.preventDefault();
      var data = $(this).data();
      var transferid = data.transferid;
      pg.queue.cancel(transferid);
    });

    $(document).on('click', '.initialdir', function (e) {
      e.preventDefault();
      var bundle = pg.utils.createBundle($(this));
      pg.list.get(bundle._package, "");
    });

    $(document).on('click', 'td.queue-remove', function (e) {
      e.preventDefault();
      pg.queue.remove($(this));
    });

    $(document).on('click', '.action-removefromqueue', function (e) {
      e.preventDefault();
      var nodeInfo = pg.utils.getNodeInfo($(this));
      var cells = nodeInfo.node.$elems.queue.find('td.selected');
      if (cells.length > 0) {
        pg.queue.remove(cells);
      } else {
        pg.utils.notifications.show( 'notify.queue_no_files_selected' );
      }
    });

    $(document).on('click', 'tr.directory td:not(.icon-queue):not(.icon-checkbox)', function (e) {
      e.preventDefault();
      var bundle = pg.utils.createBundle($(this));
      pg.list.get(bundle._package, bundle.path);
    });

    $(document).on('click', 'td.icon-checkbox', function (e) {
      var $this = $(this);
      var nodeInfo = pg.utils.getNodeInfo($this);
      pg.ui.selectClick($this, e, nodeInfo.node);
    });

    $(document).on('click', '.transferButtonGroup ul a', function (e) {
      e.preventDefault();
      pg.ui.transferButtonList.updateSelected(this);
    });

    $(document).on('click', '.downloadButton', function (e) {
      //TODO: break functionality out into API-accessible modular parts
      e.preventDefault();
      var $this = $(this);
      var thisId = pg.utils.splitString($this.attr('id'));
      var configObj = pg.config.downloadButtons[thisId];
      var connectionKey = pg.utils.connectionKeyFromId(thisId);
      $this.data('connectionKey', connectionKey);

      // check to see if there is a queue
      if (configObj.fileList.length <= 0) {
        pg.utils.dialog(lang.downloadButtonNoFiles);
      } else {

        var $info = $('#' + thisId + '-info');
        if ($info.length <= 0) {
          $info = $('<div id="' + +thisId + '-info" class="componentContainer"');
          $this.after($info);
        } else {
          // show the info (status) area
          pg.ui.reveal($info);
        }
        var uniqueId = thisId + '-' + connectionKey;

        // make new storedNode
        pg.storedNodes[uniqueId] = {
          id: thisId,
          connectionKey: connectionKey,
          $elems: {
            info: $info
          },
          queue: {
            fileList: configObj.fileList
          }
        };
        if (pg.config.webapp.showDownloadButtonProgress) {
          pg.ui.makeInfo(pg.storedNodes[uniqueId]);
        }
        pg.queue.transfer(pg.storedNodes[thisId + '-' + connectionKey]);
      }
    });

    $(document).on('click', '.revealPath', function (e) {
      e.preventDefault();
      var data = $(this).data();
      var path = data.path;
      pg.utils.revealPath(path);
    });

    $(document).on('click', '.ta-list .breadcrumb a', function (e) {
      e.preventDefault();
      var $this = $(this);
      var key = $this.closest('.componentContainer').data('connectionKey');
      var _package = pg.storedNodes[key];
      var path = $this.attr('href');
      pg.list.get(_package, path);
    });

    $(document).on('click', '#launchTryAgain', function (e) {
      e.preventDefault();
      pg.dialog.handlers.launch();
    });

    $( document ).on( 'click', '#launchDownload', function ( e ) {
      e.preventDefault();
      pg.dialog.handlers.download();
    } );

    $(document).on('click', '.fileList .sortable', function (e) {
      e.preventDefault();
      var $this = $(this);
      var invert = true;

      // determine and store the type of sort
      var colType = pg.utils.splitString(this.id, '-');
      pg.localConfig.sortColumn = colType;

      // modify the value of the inversion only if clicking a sort column, since
      // this will change the sort intention. Otherwise, allow the list method
      // to retrieve the cookied or default value
      if ($this.hasClass('headerSortUp') || $this.hasClass('headerSortDown')) {
        if ($this.hasClass('headerSortDown')) {
          invert = false;
        }
        pg.localConfig.invertSort = invert;
      }

      $.cookie('filecatalystLocalConfig', JSON.stringify(pg.localConfig), {expires: 365});
      var key = $(this).closest('.componentContainer').data('connectionKey');
      var _package = pg.storedNodes[key];
      var path = _package.directory;
      pg.list.get(_package, path);
    });

    $(document).on('keyup', '#portValue', function () {
      var $this = $(this);
      var thePort = parseInt($this.val());
      pg.utils.updateConfig('http.port', thePort, "INTEGER");
    });

    $(document).on('click', '.downloadPathInstructions', function (e) {
      e.preventDefault();
      pg.dialog.downloadPathInformation();
    });
  })();

  // fire on document ready. Initialize deals primarily with UI and therefore
  // the DOM must be scriptable. pg.initialize() should always be on document ready
  // for pages that connect to local TransferAgent or remote FileCatalyst Servers
  $(document).ready(function () {
    $(".help-anchor").attr("href", pg.utils.baseUrl("help", undefined, true) + "help/TransferAgent/help.html#webui");

    if (typeof (window.overrideAutoconnect) === "undefined") {
      window.overrideAutoconnect = false;
    }
    $(document).on("keydown", ".username, .password", function (e) {
      if (e.which === 13) {
        pg.executeLogin();
        $(".confirmCredentials").modal("hide");
      }
    });
	
	// i18n is now loaded
	pg.i18nLoaded = true;

    if ( ( pg.config.webapp.autoConnect && !window.overrideAutoconnect ) || pg.initializationQueued ) {
      pg.initialize();
	  // Initialization queueing is no longer needed - it is safe to start initialization whenever needed.
	  pg.initializationQueued = false;
    }
    $('[data-toggle="popover"]').popover();
    var elementPopover = "pg.utils.closePopover('iconRemoveCredentials')";
    var contentPopover =
        '<button class="btn btn-sm btn-success" onclick="pg.utils.removeSavedLogin()">' + lang.tooltips.yes
        + '</button><button class="btn btn-sm btn-primary" onclick="' + elementPopover + '">' + lang.tooltips.no
        + '</button>';
    $("#iconRemoveCredentials").popover({
      title: lang.tooltips.removeCredentialsWarning,
      content: contentPopover,
      html: true,
      placement: "bottom"
    });

  });
  $("body").i18n();

  pg.utils.notifications = function () {

    /**
     * Wrapper for the current notifications library. Also contains the functionality needed to modify existing
     * notifications.
     */
    function Notifications () {

        var func      = this;

        func.list     = {};
        func.defaults = {
            type:      'success',
            placement: {
                from:    'top'
            },
            offset:    55,
            width:     350, // May not be supported
            delay:     2000
        };

        func.add     = add;
        func.replace = replace;
        func.show    = show;

        /**
         * Initialize the notifications object.
         */
        function _initialize() {

            // Setting defaults for notify
            $.notifyDefaults( func.defaults );

            // If notifications are not suppressed
            if ( pg.config.webapp.suppressNotifications === undefined || !pg.config.webapp.suppressNotifications ) {

                // Register all notifications with their settings and associated events
                // func.list.
                func.list = {
                    'notify.download': [ {
                        message: lang.downloadNotify,
                        options: { delay: 10000, type: 'warning' }
                    } ],
                    'notify.upgrade': [ {
                        message: lang.upgradeNotify,
                        options: { delay: 10000, type: 'warning' }
                    } ],
                    'notify.resource_not_accessible_code': [ {
                        message: '{0}: ' + lang.errorNotAccessibleMessage,
                        options: { type: 'danger', delay: 1500 }
                    } ],
                    'notify.resource_not_accessible': [ {
                        message: lang.errorNotAccessibleMessage,
                        options: { type: 'danger', delay: 1500 }
                    } ],
                    'notify.file_transfer_complete': [ {
                        message: lang.transferCompleteMessage
                    } ],
                    'notify.file_transfer_cancelled': [ {
                        message: lang.transferCancelledMessage
                    } ],
                    'notify.file_transfer_error': [ {
                        message: lang.fileTransferError,
                        options: { type: 'warning', delay: 10000 }
                    } ],
                    'notify.queue_directories_not_allowed': [ {
                        message: '{0}: ' + lang.directoriesNotAllowedMessage,
                        options: { type: 'danger' }
                    } ],
                    'notify.queue_duplicate_multiple': [ {
                        message: lang.transferQueueMultiplesExistMessage,
                        options: { type: 'warning' }
                    } ],
                    'notify.queue_duplicate': [ {
                        message: '{0}: ' + lang.transferQueueExistsMessage,
                        options: { type: 'warning' }
                    } ],
                    'notify.filter_requirements_unmet': [ {
                        message:
                            '<p>' + lang.filterFailFileMessage + '{0}</p><p><p>' + lang.existingQueueFailureMessage
                            + '</p>',
                        options: { type: 'danger', delay: 10000 }
                    } ],
                    'notify.filter_max_files_exceeded': [ {
                        message:
                            '<p>' + lang.filterFailFileMessage + '{0}</p><p><p>' + lang.maxFilesExceededMessage
                            + '{1}</p>',
                        options: { type: 'danger', delay: 10000 }
                    } ],
                    'notify.filter_max_filesize_exceeded': [ {
                        message:
                            '<p>' + lang.filterFailFileMessage + '{0}</p><p><p>' + lang.fileSizeMaxExceededMessage
                            + '{1}</p>',
                        options: { type: 'danger', delay: 10000 }
                    } ],
                    'notify.filter_min_filesize_unmet': [ {
                        message:
                            '<p>' + lang.filterFailFileMessage + '{0}</p><p><p>' + lang.fileSizeMinUnmetMessage
                            + '{1}</p>',
                        options: { type: 'danger', delay: 10000 }
                    } ],
                    'notify.filter_max_overall_filesize_exceeded': [ {
                        message:
                            '<p>' + lang.filterFailFileMessage + '{0}</p><p><p>' + lang.fileSizeTotalExceededMessage
                            + '{1}</p>',
                        options: { type: 'danger', delay: 10000 }
                    } ],
                    'notify.filter_regex_unmet': [ {
                        message:
                            '<p>' + lang.filterFailFileMessage + '{0}</p><p><p>' + lang.filenameRegexFailMessage
                            + '</p>',
                        options: { type: "danger", delay: 10000 }
                    } ],
                    'notify.queue_no_files_waiting': [ {
                        message: lang.queueNoFiles
                    } ],
                    'notify.queue_no_files_removed': [ {
                        message: lang.queueNoClear
                    } ],
                    'notify.queue_no_files_selected': [ {
                        message: lang.queueNoSelect
                    } ]
                };
            }
        }

        /**
         * Adds a custom notification to the list of notifications subscribed to an Amplify event.
         *
         * @param subscription The name of the event to which to subscribe the notification.
         * @param message      The content of the notification. The message can use placeholders for some data that may
         *                     be passed to the notification at runtime. They are {0} and {1}. The contents will change
         *                     depending on the event. The argument may simply be the message string, but, as with the
         *                     bootstrap-notify.js library, it can also be an object containing the "message" property
         *                     as well as a few other properties. See the bootstrap-notify.js documentation.
         * @param options      The options to use in the definition of the notification. For more information on these
         *                     options, see the bootstrap-notify.js documentation.
         */
        function add( subscription, message, options ) {

            func.list[ subscription ] = func.list[ subscription ] || [];

            // Push notification to the notification list for the specified subscription.
            func.list[ subscription ].push( {
                message: message,
                options: options
            } );
        }

        /**
         * Replaces all notifications in the list of subscribed Amplify events with the specified custom notification.
         *
         * @param subscription The name of the event to which to subscribe the notification.
         * @param message      The content of the notification. The message can use placeholders for some data that may
         *                     be passed to the notification at runtime. They are {0} and {1}. The contents will change
         *                     depending on the event. The argument may simply be the message string, but, as with the
         *                     bootstrap-notify.js library, it can also be an object containing the "message" property
         *                     as well as a few other properties. See the bootstrap-notify.js documentation.
         * @param options      The options to use in the definition of the notification. For more information on these
         *                     options, see the bootstrap-notify.js documentation.
         */
        function replace( subscription, message, options ) {

            // Reset notification list to only contain the notification specified for this subscription.
            func.list[ subscription ] = [ {
                 message: message,
                 options: options
            } ];
        }

        /**
         * Shows all notifications subscribed to the specified event.
         *
         * @param subscription The name of the event to trigger.
         * @param a1           The first argument to pass to the notification.
         * @param a2           The second argument to pass to the notification.
         */
        function show( subscription, a1, a2 ) {

            // Normalizing argument data.
            a1 = a1 || '';
            a2 = a2 || '';

            // Show all notifications registered with the specified event.
            $.each( func.list[ subscription ] || [], function ( index, currentValue ) {

                var message;

                // Insert values sent to function.
                // Had to use temporary variable -  we don't want to modify array values.
                // Also, "message" can be a string or an object.
                if ( currentValue.message === undefined ) {

                    // Sanity check here, will break if undefined.
                    message = '';
                } else if ( typeof currentValue.message !== 'string' ) {

                    message = currentValue.message;
                    message.message = message.message.replace( /\{0\}/g, a1 );
                    message.message = message.message.replace( /\{1\}/g, a2 );
                } else {

                    message = currentValue.message.replace( /\{0\}/g, a1 );
                    message = message.replace( /\{1\}/g, a2 );
                }

                $.notify( message, currentValue.options );
            } );

            // Publish specified event as an Amplify event, in case there are events subscribed to it.
            // Add information as arguments to callback.
            amplify.publish( subscription, a1, a2 );
        }

        _initialize();
    };

    // Instantiate it
    return new Notifications();
  } ();
};

// Flag to tell us if language files are loaded
pg.i18nLoaded = false;

// Flag to tell us if initialization was requested programmatically
pg.initializationQueued = false;

/**
 * Queue the initialization of the application if the language files have not loaded yet. Otherwise, start the
 * initialization. If the initialization is queued, it will be called again when the language files have loaded,
 * starting the initialization.
 *
 * Maintained as a single function for compatibility with existing systems.
 */
pg.initialize = function () {

  if ( pg.i18nLoaded === true ) {
    // If i18n is loaded, it is safe to create the interface.
    pg.init.trigger();
  } else {
    // If i18n is not yet loaded, queue the initialization for when it does. This means we requested the initialization
    // programmatically.
    pg.initializationQueued = true;
  }
};
